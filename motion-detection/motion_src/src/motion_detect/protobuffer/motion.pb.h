// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motion.proto

#ifndef PROTOBUF_motion_2eproto__INCLUDED
#define PROTOBUF_motion_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace motion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motion_2eproto();
void protobuf_AssignDesc_motion_2eproto();
void protobuf_ShutdownFile_motion_2eproto();

class Message;
class Message_MotionMonth;
class Message_MotionDay;
class Message_Instance;
class Message_Image;
class Message_Crop;

enum Message_ActionType {
  Message_ActionType_ENGAGE = 1000,
  Message_ActionType_REC_START = 1002,
  Message_ActionType_REC_RUNNING = 1003,
  Message_ActionType_REC_STOP = 1004,
  Message_ActionType_UNENGAGE = 1005,
  Message_ActionType_GET_TIME = 1006,
  Message_ActionType_SET_TIME = 1007,
  Message_ActionType_TIME_SET = 1008,
  Message_ActionType_STRM_START = 1009,
  Message_ActionType_STRM_STOP = 1010,
  Message_ActionType_TAKE_PICTURE = 1011,
  Message_ActionType_DISSCONNECT = 1012,
  Message_ActionType_REFRESH = 1013,
  Message_ActionType_GET_XML = 1014,
  Message_ActionType_GET_IMAGE = 1015,
  Message_ActionType_RESPONSE_OK = 2000,
  Message_ActionType_RESPONSE_NEXT = 2010,
  Message_ActionType_RESPONSE_END = 2020,
  Message_ActionType_RESPONSE_FINISH = 2030,
  Message_ActionType_REC_HAS_CHANGES = 2040,
  Message_ActionType_REC_HAS_INSTANCE = 2050,
  Message_ActionType_PROTO_HAS_FILE = 3030,
  Message_ActionType_PROTO_NO_FILE = 3031
};
bool Message_ActionType_IsValid(int value);
const Message_ActionType Message_ActionType_ActionType_MIN = Message_ActionType_ENGAGE;
const Message_ActionType Message_ActionType_ActionType_MAX = Message_ActionType_PROTO_NO_FILE;
const int Message_ActionType_ActionType_ARRAYSIZE = Message_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ActionType_descriptor();
inline const ::std::string& Message_ActionType_Name(Message_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ActionType_descriptor(), value);
}
inline bool Message_ActionType_Parse(
    const ::std::string& name, Message_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ActionType>(
    Message_ActionType_descriptor(), name, value);
}
enum Message_SocketType {
  Message_SocketType_SOCKET_PROTO_TOSTRING = 10,
  Message_SocketType_SOCKET_PROTO_TOARRAY = 11,
  Message_SocketType_SOCKET_PLAIN_TEXT = 12,
  Message_SocketType_SPLITTED_MESSAGE = 13,
  Message_SocketType_SINGLE_MESSAGE = 14,
  Message_SocketType_SOCKET_BUFFER_NANO_SIZE = 1024,
  Message_SocketType_SOCKET_BUFFER_MINI_SIZE = 2048,
  Message_SocketType_SOCKET_BUFFER_MICRO_SIZE = 4096,
  Message_SocketType_SOCKET_BUFFER_SMALL_SIZE = 8196,
  Message_SocketType_SOCKET_BUFFER_REGULAR_SIZE = 16392,
  Message_SocketType_SOCKET_BUFFER_MEDIUM_SIZE = 32784,
  Message_SocketType_SOCKET_BUFFER_BIG_SIZE = 65568,
  Message_SocketType_TCP_ECHO_PORT = 5010,
  Message_SocketType_TCP_STREAMING_PORT = 5020,
  Message_SocketType_UDP_PORT = 5030,
  Message_SocketType_TCP_MSG_PORT = 5040
};
bool Message_SocketType_IsValid(int value);
const Message_SocketType Message_SocketType_SocketType_MIN = Message_SocketType_SOCKET_PROTO_TOSTRING;
const Message_SocketType Message_SocketType_SocketType_MAX = Message_SocketType_SOCKET_BUFFER_BIG_SIZE;
const int Message_SocketType_SocketType_ARRAYSIZE = Message_SocketType_SocketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_SocketType_descriptor();
inline const ::std::string& Message_SocketType_Name(Message_SocketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_SocketType_descriptor(), value);
}
inline bool Message_SocketType_Parse(
    const ::std::string& name, Message_SocketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_SocketType>(
    Message_SocketType_descriptor(), name, value);
}
// ===================================================================

class Message_MotionMonth : public ::google::protobuf::Message {
 public:
  Message_MotionMonth();
  virtual ~Message_MotionMonth();

  Message_MotionMonth(const Message_MotionMonth& from);

  inline Message_MotionMonth& operator=(const Message_MotionMonth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionMonth& default_instance();

  void Swap(Message_MotionMonth* other);

  // implements Message ----------------------------------------------

  Message_MotionMonth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionMonth& from);
  void MergeFrom(const Message_MotionMonth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .motion.Message.MotionDay motionday = 1;
  inline int motionday_size() const;
  inline void clear_motionday();
  static const int kMotiondayFieldNumber = 1;
  inline const ::motion::Message_MotionDay& motionday(int index) const;
  inline ::motion::Message_MotionDay* mutable_motionday(int index);
  inline ::motion::Message_MotionDay* add_motionday();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >&
      motionday() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >*
      mutable_motionday();

  // optional string monthlabel = 2;
  inline bool has_monthlabel() const;
  inline void clear_monthlabel();
  static const int kMonthlabelFieldNumber = 2;
  inline const ::std::string& monthlabel() const;
  inline void set_monthlabel(const ::std::string& value);
  inline void set_monthlabel(const char* value);
  inline void set_monthlabel(const char* value, size_t size);
  inline ::std::string* mutable_monthlabel();
  inline ::std::string* release_monthlabel();
  inline void set_allocated_monthlabel(::std::string* monthlabel);

  // @@protoc_insertion_point(class_scope:motion.Message.MotionMonth)
 private:
  inline void set_has_monthlabel();
  inline void clear_has_monthlabel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay > motionday_;
  ::std::string* monthlabel_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionMonth* default_instance_;
};
// -------------------------------------------------------------------

class Message_MotionDay : public ::google::protobuf::Message {
 public:
  Message_MotionDay();
  virtual ~Message_MotionDay();

  Message_MotionDay(const Message_MotionDay& from);

  inline Message_MotionDay& operator=(const Message_MotionDay& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_MotionDay& default_instance();

  void Swap(Message_MotionDay* other);

  // implements Message ----------------------------------------------

  Message_MotionDay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_MotionDay& from);
  void MergeFrom(const Message_MotionDay& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string daylabel = 1;
  inline bool has_daylabel() const;
  inline void clear_daylabel();
  static const int kDaylabelFieldNumber = 1;
  inline const ::std::string& daylabel() const;
  inline void set_daylabel(const ::std::string& value);
  inline void set_daylabel(const char* value);
  inline void set_daylabel(const char* value, size_t size);
  inline ::std::string* mutable_daylabel();
  inline ::std::string* release_daylabel();
  inline void set_allocated_daylabel(::std::string* daylabel);

  // repeated .motion.Message.Instance instance = 2;
  inline int instance_size() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 2;
  inline const ::motion::Message_Instance& instance(int index) const;
  inline ::motion::Message_Instance* mutable_instance(int index);
  inline ::motion::Message_Instance* add_instance();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >&
      instance() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >*
      mutable_instance();

  // @@protoc_insertion_point(class_scope:motion.Message.MotionDay)
 private:
  inline void set_has_daylabel();
  inline void clear_has_daylabel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* daylabel_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance > instance_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_MotionDay* default_instance_;
};
// -------------------------------------------------------------------

class Message_Instance : public ::google::protobuf::Message {
 public:
  Message_Instance();
  virtual ~Message_Instance();

  Message_Instance(const Message_Instance& from);

  inline Message_Instance& operator=(const Message_Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Instance& default_instance();

  void Swap(Message_Instance* other);

  // implements Message ----------------------------------------------

  Message_Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Instance& from);
  void MergeFrom(const Message_Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idinstance = 1;
  inline bool has_idinstance() const;
  inline void clear_idinstance();
  static const int kIdinstanceFieldNumber = 1;
  inline ::google::protobuf::int32 idinstance() const;
  inline void set_idinstance(::google::protobuf::int32 value);

  // optional string instancestart = 2;
  inline bool has_instancestart() const;
  inline void clear_instancestart();
  static const int kInstancestartFieldNumber = 2;
  inline const ::std::string& instancestart() const;
  inline void set_instancestart(const ::std::string& value);
  inline void set_instancestart(const char* value);
  inline void set_instancestart(const char* value, size_t size);
  inline ::std::string* mutable_instancestart();
  inline ::std::string* release_instancestart();
  inline void set_allocated_instancestart(::std::string* instancestart);

  // optional string instanceend = 3;
  inline bool has_instanceend() const;
  inline void clear_instanceend();
  static const int kInstanceendFieldNumber = 3;
  inline const ::std::string& instanceend() const;
  inline void set_instanceend(const ::std::string& value);
  inline void set_instanceend(const char* value);
  inline void set_instanceend(const char* value, size_t size);
  inline ::std::string* mutable_instanceend();
  inline ::std::string* release_instanceend();
  inline void set_allocated_instanceend(::std::string* instanceend);

  // optional string fileformat = 4;
  inline bool has_fileformat() const;
  inline void clear_fileformat();
  static const int kFileformatFieldNumber = 4;
  inline const ::std::string& fileformat() const;
  inline void set_fileformat(const ::std::string& value);
  inline void set_fileformat(const char* value);
  inline void set_fileformat(const char* value, size_t size);
  inline ::std::string* mutable_fileformat();
  inline ::std::string* release_fileformat();
  inline void set_allocated_fileformat(::std::string* fileformat);

  // optional string croppedformat = 5;
  inline bool has_croppedformat() const;
  inline void clear_croppedformat();
  static const int kCroppedformatFieldNumber = 5;
  inline const ::std::string& croppedformat() const;
  inline void set_croppedformat(const ::std::string& value);
  inline void set_croppedformat(const char* value);
  inline void set_croppedformat(const char* value, size_t size);
  inline ::std::string* mutable_croppedformat();
  inline ::std::string* release_croppedformat();
  inline void set_allocated_croppedformat(::std::string* croppedformat);

  // repeated .motion.Message.Image image = 6;
  inline int image_size() const;
  inline void clear_image();
  static const int kImageFieldNumber = 6;
  inline const ::motion::Message_Image& image(int index) const;
  inline ::motion::Message_Image* mutable_image(int index);
  inline ::motion::Message_Image* add_image();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >&
      image() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >*
      mutable_image();

  // repeated .motion.Message.Crop crop = 7;
  inline int crop_size() const;
  inline void clear_crop();
  static const int kCropFieldNumber = 7;
  inline const ::motion::Message_Crop& crop(int index) const;
  inline ::motion::Message_Crop* mutable_crop(int index);
  inline ::motion::Message_Crop* add_crop();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >&
      crop() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >*
      mutable_crop();

  // @@protoc_insertion_point(class_scope:motion.Message.Instance)
 private:
  inline void set_has_idinstance();
  inline void clear_has_idinstance();
  inline void set_has_instancestart();
  inline void clear_has_instancestart();
  inline void set_has_instanceend();
  inline void clear_has_instanceend();
  inline void set_has_fileformat();
  inline void clear_has_fileformat();
  inline void set_has_croppedformat();
  inline void clear_has_croppedformat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* instancestart_;
  ::std::string* instanceend_;
  ::std::string* fileformat_;
  ::std::string* croppedformat_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Image > image_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop > crop_;
  ::google::protobuf::int32 idinstance_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Instance* default_instance_;
};
// -------------------------------------------------------------------

class Message_Image : public ::google::protobuf::Message {
 public:
  Message_Image();
  virtual ~Message_Image();

  Message_Image(const Message_Image& from);

  inline Message_Image& operator=(const Message_Image& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Image& default_instance();

  void Swap(Message_Image* other);

  // implements Message ----------------------------------------------

  Message_Image* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Image& from);
  void MergeFrom(const Message_Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 imagechanges = 3;
  inline bool has_imagechanges() const;
  inline void clear_imagechanges();
  static const int kImagechangesFieldNumber = 3;
  inline ::google::protobuf::int32 imagechanges() const;
  inline void set_imagechanges(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message.Image)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_imagechanges();
  inline void clear_has_imagechanges();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* name_;
  ::google::protobuf::int32 imagechanges_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Image* default_instance_;
};
// -------------------------------------------------------------------

class Message_Crop : public ::google::protobuf::Message {
 public:
  Message_Crop();
  virtual ~Message_Crop();

  Message_Crop(const Message_Crop& from);

  inline Message_Crop& operator=(const Message_Crop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_Crop& default_instance();

  void Swap(Message_Crop* other);

  // implements Message ----------------------------------------------

  Message_Crop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_Crop& from);
  void MergeFrom(const Message_Crop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string imagefather = 3;
  inline bool has_imagefather() const;
  inline void clear_imagefather();
  static const int kImagefatherFieldNumber = 3;
  inline const ::std::string& imagefather() const;
  inline void set_imagefather(const ::std::string& value);
  inline void set_imagefather(const char* value);
  inline void set_imagefather(const char* value, size_t size);
  inline ::std::string* mutable_imagefather();
  inline ::std::string* release_imagefather();
  inline void set_allocated_imagefather(::std::string* imagefather);

  // @@protoc_insertion_point(class_scope:motion.Message.Crop)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_imagefather();
  inline void clear_has_imagefather();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* imagefather_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message_Crop* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_MotionMonth MotionMonth;
  typedef Message_MotionDay MotionDay;
  typedef Message_Instance Instance;
  typedef Message_Image Image;
  typedef Message_Crop Crop;

  typedef Message_ActionType ActionType;
  static const ActionType ENGAGE = Message_ActionType_ENGAGE;
  static const ActionType REC_START = Message_ActionType_REC_START;
  static const ActionType REC_RUNNING = Message_ActionType_REC_RUNNING;
  static const ActionType REC_STOP = Message_ActionType_REC_STOP;
  static const ActionType UNENGAGE = Message_ActionType_UNENGAGE;
  static const ActionType GET_TIME = Message_ActionType_GET_TIME;
  static const ActionType SET_TIME = Message_ActionType_SET_TIME;
  static const ActionType TIME_SET = Message_ActionType_TIME_SET;
  static const ActionType STRM_START = Message_ActionType_STRM_START;
  static const ActionType STRM_STOP = Message_ActionType_STRM_STOP;
  static const ActionType TAKE_PICTURE = Message_ActionType_TAKE_PICTURE;
  static const ActionType DISSCONNECT = Message_ActionType_DISSCONNECT;
  static const ActionType REFRESH = Message_ActionType_REFRESH;
  static const ActionType GET_XML = Message_ActionType_GET_XML;
  static const ActionType GET_IMAGE = Message_ActionType_GET_IMAGE;
  static const ActionType RESPONSE_OK = Message_ActionType_RESPONSE_OK;
  static const ActionType RESPONSE_NEXT = Message_ActionType_RESPONSE_NEXT;
  static const ActionType RESPONSE_END = Message_ActionType_RESPONSE_END;
  static const ActionType RESPONSE_FINISH = Message_ActionType_RESPONSE_FINISH;
  static const ActionType REC_HAS_CHANGES = Message_ActionType_REC_HAS_CHANGES;
  static const ActionType REC_HAS_INSTANCE = Message_ActionType_REC_HAS_INSTANCE;
  static const ActionType PROTO_HAS_FILE = Message_ActionType_PROTO_HAS_FILE;
  static const ActionType PROTO_NO_FILE = Message_ActionType_PROTO_NO_FILE;
  static inline bool ActionType_IsValid(int value) {
    return Message_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Message_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Message_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Message_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Message_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Message_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Message_ActionType_Parse(name, value);
  }

  typedef Message_SocketType SocketType;
  static const SocketType SOCKET_PROTO_TOSTRING = Message_SocketType_SOCKET_PROTO_TOSTRING;
  static const SocketType SOCKET_PROTO_TOARRAY = Message_SocketType_SOCKET_PROTO_TOARRAY;
  static const SocketType SOCKET_PLAIN_TEXT = Message_SocketType_SOCKET_PLAIN_TEXT;
  static const SocketType SPLITTED_MESSAGE = Message_SocketType_SPLITTED_MESSAGE;
  static const SocketType SINGLE_MESSAGE = Message_SocketType_SINGLE_MESSAGE;
  static const SocketType SOCKET_BUFFER_NANO_SIZE = Message_SocketType_SOCKET_BUFFER_NANO_SIZE;
  static const SocketType SOCKET_BUFFER_MINI_SIZE = Message_SocketType_SOCKET_BUFFER_MINI_SIZE;
  static const SocketType SOCKET_BUFFER_MICRO_SIZE = Message_SocketType_SOCKET_BUFFER_MICRO_SIZE;
  static const SocketType SOCKET_BUFFER_SMALL_SIZE = Message_SocketType_SOCKET_BUFFER_SMALL_SIZE;
  static const SocketType SOCKET_BUFFER_REGULAR_SIZE = Message_SocketType_SOCKET_BUFFER_REGULAR_SIZE;
  static const SocketType SOCKET_BUFFER_MEDIUM_SIZE = Message_SocketType_SOCKET_BUFFER_MEDIUM_SIZE;
  static const SocketType SOCKET_BUFFER_BIG_SIZE = Message_SocketType_SOCKET_BUFFER_BIG_SIZE;
  static const SocketType TCP_ECHO_PORT = Message_SocketType_TCP_ECHO_PORT;
  static const SocketType TCP_STREAMING_PORT = Message_SocketType_TCP_STREAMING_PORT;
  static const SocketType UDP_PORT = Message_SocketType_UDP_PORT;
  static const SocketType TCP_MSG_PORT = Message_SocketType_TCP_MSG_PORT;
  static inline bool SocketType_IsValid(int value) {
    return Message_SocketType_IsValid(value);
  }
  static const SocketType SocketType_MIN =
    Message_SocketType_SocketType_MIN;
  static const SocketType SocketType_MAX =
    Message_SocketType_SocketType_MAX;
  static const int SocketType_ARRAYSIZE =
    Message_SocketType_SocketType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SocketType_descriptor() {
    return Message_SocketType_descriptor();
  }
  static inline const ::std::string& SocketType_Name(SocketType value) {
    return Message_SocketType_Name(value);
  }
  static inline bool SocketType_Parse(const ::std::string& name,
      SocketType* value) {
    return Message_SocketType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .motion.Message.ActionType type = 1 [default = ENGAGE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::motion::Message_ActionType type() const;
  inline void set_type(::motion::Message_ActionType value);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional bytes data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional int32 data_amount = 4;
  inline bool has_data_amount() const;
  inline void clear_data_amount();
  static const int kDataAmountFieldNumber = 4;
  inline ::google::protobuf::int32 data_amount() const;
  inline void set_data_amount(::google::protobuf::int32 value);

  // optional int32 data_total = 5;
  inline bool has_data_total() const;
  inline void clear_data_total();
  static const int kDataTotalFieldNumber = 5;
  inline ::google::protobuf::int32 data_total() const;
  inline void set_data_total(::google::protobuf::int32 value);

  // optional string serverip = 6;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServeripFieldNumber = 6;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional string clientip = 7;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientipFieldNumber = 7;
  inline const ::std::string& clientip() const;
  inline void set_clientip(const ::std::string& value);
  inline void set_clientip(const char* value);
  inline void set_clientip(const char* value, size_t size);
  inline ::std::string* mutable_clientip();
  inline ::std::string* release_clientip();
  inline void set_allocated_clientip(::std::string* clientip);

  // optional bool recognizing = 8;
  inline bool has_recognizing() const;
  inline void clear_recognizing();
  static const int kRecognizingFieldNumber = 8;
  inline bool recognizing() const;
  inline void set_recognizing(bool value);

  // repeated .motion.Message.MotionMonth motionmonth = 9;
  inline int motionmonth_size() const;
  inline void clear_motionmonth();
  static const int kMotionmonthFieldNumber = 9;
  inline const ::motion::Message_MotionMonth& motionmonth(int index) const;
  inline ::motion::Message_MotionMonth* mutable_motionmonth(int index);
  inline ::motion::Message_MotionMonth* add_motionmonth();
  inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >&
      motionmonth() const;
  inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >*
      mutable_motionmonth();

  // optional bool storeimage = 10;
  inline bool has_storeimage() const;
  inline void clear_storeimage();
  static const int kStoreimageFieldNumber = 10;
  inline bool storeimage() const;
  inline void set_storeimage(bool value);

  // optional bool storecrop = 11;
  inline bool has_storecrop() const;
  inline void clear_storecrop();
  static const int kStorecropFieldNumber = 11;
  inline bool storecrop() const;
  inline void set_storecrop(bool value);

  // optional string codename = 12;
  inline bool has_codename() const;
  inline void clear_codename();
  static const int kCodenameFieldNumber = 12;
  inline const ::std::string& codename() const;
  inline void set_codename(const ::std::string& value);
  inline void set_codename(const char* value);
  inline void set_codename(const char* value, size_t size);
  inline ::std::string* mutable_codename();
  inline ::std::string* release_codename();
  inline void set_allocated_codename(::std::string* codename);

  // optional bytes regioncoords = 13;
  inline bool has_regioncoords() const;
  inline void clear_regioncoords();
  static const int kRegioncoordsFieldNumber = 13;
  inline const ::std::string& regioncoords() const;
  inline void set_regioncoords(const ::std::string& value);
  inline void set_regioncoords(const char* value);
  inline void set_regioncoords(const void* value, size_t size);
  inline ::std::string* mutable_regioncoords();
  inline ::std::string* release_regioncoords();
  inline void set_allocated_regioncoords(::std::string* regioncoords);

  // optional double delay = 14;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 14;
  inline double delay() const;
  inline void set_delay(double value);

  // optional string starttime = 15;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 15;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string startrecognitiontime = 16;
  inline bool has_startrecognitiontime() const;
  inline void clear_startrecognitiontime();
  static const int kStartrecognitiontimeFieldNumber = 16;
  inline const ::std::string& startrecognitiontime() const;
  inline void set_startrecognitiontime(const ::std::string& value);
  inline void set_startrecognitiontime(const char* value);
  inline void set_startrecognitiontime(const char* value, size_t size);
  inline ::std::string* mutable_startrecognitiontime();
  inline ::std::string* release_startrecognitiontime();
  inline void set_allocated_startrecognitiontime(::std::string* startrecognitiontime);

  // optional bool region = 17;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 17;
  inline bool region() const;
  inline void set_region(bool value);

  // optional int32 numberofchanges = 18;
  inline bool has_numberofchanges() const;
  inline void clear_numberofchanges();
  static const int kNumberofchangesFieldNumber = 18;
  inline ::google::protobuf::int32 numberofchanges() const;
  inline void set_numberofchanges(::google::protobuf::int32 value);

  // optional int32 amount = 19;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 19;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // repeated int32 matfile = 20;
  inline int matfile_size() const;
  inline void clear_matfile();
  static const int kMatfileFieldNumber = 20;
  inline ::google::protobuf::int32 matfile(int index) const;
  inline void set_matfile(int index, ::google::protobuf::int32 value);
  inline void add_matfile(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      matfile() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_matfile();

  // optional int32 activemat = 21;
  inline bool has_activemat() const;
  inline void clear_activemat();
  static const int kActivematFieldNumber = 21;
  inline ::google::protobuf::int32 activemat() const;
  inline void set_activemat(::google::protobuf::int32 value);

  // optional string cameras = 22;
  inline bool has_cameras() const;
  inline void clear_cameras();
  static const int kCamerasFieldNumber = 22;
  inline const ::std::string& cameras() const;
  inline void set_cameras(const ::std::string& value);
  inline void set_cameras(const char* value);
  inline void set_cameras(const char* value, size_t size);
  inline ::std::string* mutable_cameras();
  inline ::std::string* release_cameras();
  inline void set_allocated_cameras(::std::string* cameras);

  // optional int32 activecamera = 23;
  inline bool has_activecamera() const;
  inline void clear_activecamera();
  static const int kActivecameraFieldNumber = 23;
  inline ::google::protobuf::int32 activecamera() const;
  inline void set_activecamera(::google::protobuf::int32 value);

  // optional string xmlfilename = 24;
  inline bool has_xmlfilename() const;
  inline void clear_xmlfilename();
  static const int kXmlfilenameFieldNumber = 24;
  inline const ::std::string& xmlfilename() const;
  inline void set_xmlfilename(const ::std::string& value);
  inline void set_xmlfilename(const char* value);
  inline void set_xmlfilename(const char* value, size_t size);
  inline ::std::string* mutable_xmlfilename();
  inline ::std::string* release_xmlfilename();
  inline void set_allocated_xmlfilename(::std::string* xmlfilename);

  // optional string xmlfilepath = 25;
  inline bool has_xmlfilepath() const;
  inline void clear_xmlfilepath();
  static const int kXmlfilepathFieldNumber = 25;
  inline const ::std::string& xmlfilepath() const;
  inline void set_xmlfilepath(const ::std::string& value);
  inline void set_xmlfilepath(const char* value);
  inline void set_xmlfilepath(const char* value, size_t size);
  inline ::std::string* mutable_xmlfilepath();
  inline ::std::string* release_xmlfilepath();
  inline void set_allocated_xmlfilepath(::std::string* xmlfilepath);

  // optional int32 instancecount = 26;
  inline bool has_instancecount() const;
  inline void clear_instancecount();
  static const int kInstancecountFieldNumber = 26;
  inline ::google::protobuf::int32 instancecount() const;
  inline void set_instancecount(::google::protobuf::int32 value);

  // optional string imagefilepath = 27;
  inline bool has_imagefilepath() const;
  inline void clear_imagefilepath();
  static const int kImagefilepathFieldNumber = 27;
  inline const ::std::string& imagefilepath() const;
  inline void set_imagefilepath(const ::std::string& value);
  inline void set_imagefilepath(const char* value);
  inline void set_imagefilepath(const char* value, size_t size);
  inline ::std::string* mutable_imagefilepath();
  inline ::std::string* release_imagefilepath();
  inline void set_allocated_imagefilepath(::std::string* imagefilepath);

  // optional string currmonth = 28;
  inline bool has_currmonth() const;
  inline void clear_currmonth();
  static const int kCurrmonthFieldNumber = 28;
  inline const ::std::string& currmonth() const;
  inline void set_currmonth(const ::std::string& value);
  inline void set_currmonth(const char* value);
  inline void set_currmonth(const char* value, size_t size);
  inline ::std::string* mutable_currmonth();
  inline ::std::string* release_currmonth();
  inline void set_allocated_currmonth(::std::string* currmonth);

  // optional string currday = 29;
  inline bool has_currday() const;
  inline void clear_currday();
  static const int kCurrdayFieldNumber = 29;
  inline const ::std::string& currday() const;
  inline void set_currday(const ::std::string& value);
  inline void set_currday(const char* value);
  inline void set_currday(const char* value, size_t size);
  inline ::std::string* mutable_currday();
  inline ::std::string* release_currday();
  inline void set_allocated_currday(::std::string* currday);

  // optional int32 packagesize = 30;
  inline bool has_packagesize() const;
  inline void clear_packagesize();
  static const int kPackagesizeFieldNumber = 30;
  inline ::google::protobuf::int32 packagesize() const;
  inline void set_packagesize(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:motion.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_data_amount();
  inline void clear_has_data_amount();
  inline void set_has_data_total();
  inline void clear_has_data_total();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_recognizing();
  inline void clear_has_recognizing();
  inline void set_has_storeimage();
  inline void clear_has_storeimage();
  inline void set_has_storecrop();
  inline void clear_has_storecrop();
  inline void set_has_codename();
  inline void clear_has_codename();
  inline void set_has_regioncoords();
  inline void clear_has_regioncoords();
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_startrecognitiontime();
  inline void clear_has_startrecognitiontime();
  inline void set_has_region();
  inline void clear_has_region();
  inline void set_has_numberofchanges();
  inline void clear_has_numberofchanges();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_activemat();
  inline void clear_has_activemat();
  inline void set_has_cameras();
  inline void clear_has_cameras();
  inline void set_has_activecamera();
  inline void clear_has_activecamera();
  inline void set_has_xmlfilename();
  inline void clear_has_xmlfilename();
  inline void set_has_xmlfilepath();
  inline void clear_has_xmlfilepath();
  inline void set_has_instancecount();
  inline void clear_has_instancecount();
  inline void set_has_imagefilepath();
  inline void clear_has_imagefilepath();
  inline void set_has_currmonth();
  inline void clear_has_currmonth();
  inline void set_has_currday();
  inline void clear_has_currday();
  inline void set_has_packagesize();
  inline void clear_has_packagesize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_;
  int type_;
  ::google::protobuf::int32 data_amount_;
  ::std::string* data_;
  ::std::string* serverip_;
  ::std::string* clientip_;
  ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth > motionmonth_;
  ::google::protobuf::int32 data_total_;
  bool recognizing_;
  bool storeimage_;
  bool storecrop_;
  bool region_;
  ::std::string* codename_;
  ::std::string* regioncoords_;
  double delay_;
  ::std::string* starttime_;
  ::std::string* startrecognitiontime_;
  ::google::protobuf::int32 numberofchanges_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > matfile_;
  ::std::string* cameras_;
  ::google::protobuf::int32 activemat_;
  ::google::protobuf::int32 activecamera_;
  ::std::string* xmlfilename_;
  ::std::string* xmlfilepath_;
  ::std::string* imagefilepath_;
  ::std::string* currmonth_;
  ::google::protobuf::int32 instancecount_;
  ::google::protobuf::int32 packagesize_;
  ::std::string* currday_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Message_MotionMonth

// repeated .motion.Message.MotionDay motionday = 1;
inline int Message_MotionMonth::motionday_size() const {
  return motionday_.size();
}
inline void Message_MotionMonth::clear_motionday() {
  motionday_.Clear();
}
inline const ::motion::Message_MotionDay& Message_MotionMonth::motionday(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionMonth.motionday)
  return motionday_.Get(index);
}
inline ::motion::Message_MotionDay* Message_MotionMonth::mutable_motionday(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionMonth.motionday)
  return motionday_.Mutable(index);
}
inline ::motion::Message_MotionDay* Message_MotionMonth::add_motionday() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionMonth.motionday)
  return motionday_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >&
Message_MotionMonth::motionday() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionMonth.motionday)
  return motionday_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionDay >*
Message_MotionMonth::mutable_motionday() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionMonth.motionday)
  return &motionday_;
}

// optional string monthlabel = 2;
inline bool Message_MotionMonth::has_monthlabel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_MotionMonth::set_has_monthlabel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_MotionMonth::clear_has_monthlabel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_MotionMonth::clear_monthlabel() {
  if (monthlabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_->clear();
  }
  clear_has_monthlabel();
}
inline const ::std::string& Message_MotionMonth::monthlabel() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionMonth.monthlabel)
  return *monthlabel_;
}
inline void Message_MotionMonth::set_monthlabel(const ::std::string& value) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionMonth.monthlabel)
}
inline void Message_MotionMonth::set_monthlabel(const char* value) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionMonth.monthlabel)
}
inline void Message_MotionMonth::set_monthlabel(const char* value, size_t size) {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  monthlabel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionMonth.monthlabel)
}
inline ::std::string* Message_MotionMonth::mutable_monthlabel() {
  set_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    monthlabel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionMonth.monthlabel)
  return monthlabel_;
}
inline ::std::string* Message_MotionMonth::release_monthlabel() {
  clear_has_monthlabel();
  if (monthlabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = monthlabel_;
    monthlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionMonth::set_allocated_monthlabel(::std::string* monthlabel) {
  if (monthlabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete monthlabel_;
  }
  if (monthlabel) {
    set_has_monthlabel();
    monthlabel_ = monthlabel;
  } else {
    clear_has_monthlabel();
    monthlabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionMonth.monthlabel)
}

// -------------------------------------------------------------------

// Message_MotionDay

// optional string daylabel = 1;
inline bool Message_MotionDay::has_daylabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_MotionDay::set_has_daylabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_MotionDay::clear_has_daylabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_MotionDay::clear_daylabel() {
  if (daylabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_->clear();
  }
  clear_has_daylabel();
}
inline const ::std::string& Message_MotionDay::daylabel() const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.daylabel)
  return *daylabel_;
}
inline void Message_MotionDay::set_daylabel(const ::std::string& value) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.MotionDay.daylabel)
}
inline void Message_MotionDay::set_daylabel(const char* value) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.MotionDay.daylabel)
}
inline void Message_MotionDay::set_daylabel(const char* value, size_t size) {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  daylabel_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.MotionDay.daylabel)
}
inline ::std::string* Message_MotionDay::mutable_daylabel() {
  set_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    daylabel_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.daylabel)
  return daylabel_;
}
inline ::std::string* Message_MotionDay::release_daylabel() {
  clear_has_daylabel();
  if (daylabel_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = daylabel_;
    daylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_MotionDay::set_allocated_daylabel(::std::string* daylabel) {
  if (daylabel_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete daylabel_;
  }
  if (daylabel) {
    set_has_daylabel();
    daylabel_ = daylabel;
  } else {
    clear_has_daylabel();
    daylabel_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.MotionDay.daylabel)
}

// repeated .motion.Message.Instance instance = 2;
inline int Message_MotionDay::instance_size() const {
  return instance_.size();
}
inline void Message_MotionDay::clear_instance() {
  instance_.Clear();
}
inline const ::motion::Message_Instance& Message_MotionDay::instance(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.MotionDay.instance)
  return instance_.Get(index);
}
inline ::motion::Message_Instance* Message_MotionDay::mutable_instance(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.MotionDay.instance)
  return instance_.Mutable(index);
}
inline ::motion::Message_Instance* Message_MotionDay::add_instance() {
  // @@protoc_insertion_point(field_add:motion.Message.MotionDay.instance)
  return instance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >&
Message_MotionDay::instance() const {
  // @@protoc_insertion_point(field_list:motion.Message.MotionDay.instance)
  return instance_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Instance >*
Message_MotionDay::mutable_instance() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.MotionDay.instance)
  return &instance_;
}

// -------------------------------------------------------------------

// Message_Instance

// required int32 idinstance = 1;
inline bool Message_Instance::has_idinstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Instance::set_has_idinstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Instance::clear_has_idinstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Instance::clear_idinstance() {
  idinstance_ = 0;
  clear_has_idinstance();
}
inline ::google::protobuf::int32 Message_Instance::idinstance() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.idinstance)
  return idinstance_;
}
inline void Message_Instance::set_idinstance(::google::protobuf::int32 value) {
  set_has_idinstance();
  idinstance_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Instance.idinstance)
}

// optional string instancestart = 2;
inline bool Message_Instance::has_instancestart() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Instance::set_has_instancestart() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Instance::clear_has_instancestart() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Instance::clear_instancestart() {
  if (instancestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_->clear();
  }
  clear_has_instancestart();
}
inline const ::std::string& Message_Instance::instancestart() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instancestart)
  return *instancestart_;
}
inline void Message_Instance::set_instancestart(const ::std::string& value) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instancestart)
}
inline void Message_Instance::set_instancestart(const char* value) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instancestart)
}
inline void Message_Instance::set_instancestart(const char* value, size_t size) {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  instancestart_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instancestart)
}
inline ::std::string* Message_Instance::mutable_instancestart() {
  set_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instancestart_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instancestart)
  return instancestart_;
}
inline ::std::string* Message_Instance::release_instancestart() {
  clear_has_instancestart();
  if (instancestart_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instancestart_;
    instancestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instancestart(::std::string* instancestart) {
  if (instancestart_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instancestart_;
  }
  if (instancestart) {
    set_has_instancestart();
    instancestart_ = instancestart;
  } else {
    clear_has_instancestart();
    instancestart_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instancestart)
}

// optional string instanceend = 3;
inline bool Message_Instance::has_instanceend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Instance::set_has_instanceend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Instance::clear_has_instanceend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Instance::clear_instanceend() {
  if (instanceend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_->clear();
  }
  clear_has_instanceend();
}
inline const ::std::string& Message_Instance::instanceend() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.instanceend)
  return *instanceend_;
}
inline void Message_Instance::set_instanceend(const ::std::string& value) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.instanceend)
}
inline void Message_Instance::set_instanceend(const char* value) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.instanceend)
}
inline void Message_Instance::set_instanceend(const char* value, size_t size) {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  instanceend_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.instanceend)
}
inline ::std::string* Message_Instance::mutable_instanceend() {
  set_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    instanceend_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.instanceend)
  return instanceend_;
}
inline ::std::string* Message_Instance::release_instanceend() {
  clear_has_instanceend();
  if (instanceend_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = instanceend_;
    instanceend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_instanceend(::std::string* instanceend) {
  if (instanceend_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete instanceend_;
  }
  if (instanceend) {
    set_has_instanceend();
    instanceend_ = instanceend;
  } else {
    clear_has_instanceend();
    instanceend_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.instanceend)
}

// optional string fileformat = 4;
inline bool Message_Instance::has_fileformat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message_Instance::set_has_fileformat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message_Instance::clear_has_fileformat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message_Instance::clear_fileformat() {
  if (fileformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_->clear();
  }
  clear_has_fileformat();
}
inline const ::std::string& Message_Instance::fileformat() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.fileformat)
  return *fileformat_;
}
inline void Message_Instance::set_fileformat(const ::std::string& value) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.fileformat)
}
inline void Message_Instance::set_fileformat(const char* value) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.fileformat)
}
inline void Message_Instance::set_fileformat(const char* value, size_t size) {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  fileformat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.fileformat)
}
inline ::std::string* Message_Instance::mutable_fileformat() {
  set_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fileformat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.fileformat)
  return fileformat_;
}
inline ::std::string* Message_Instance::release_fileformat() {
  clear_has_fileformat();
  if (fileformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fileformat_;
    fileformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_fileformat(::std::string* fileformat) {
  if (fileformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fileformat_;
  }
  if (fileformat) {
    set_has_fileformat();
    fileformat_ = fileformat;
  } else {
    clear_has_fileformat();
    fileformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.fileformat)
}

// optional string croppedformat = 5;
inline bool Message_Instance::has_croppedformat() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message_Instance::set_has_croppedformat() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message_Instance::clear_has_croppedformat() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message_Instance::clear_croppedformat() {
  if (croppedformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    croppedformat_->clear();
  }
  clear_has_croppedformat();
}
inline const ::std::string& Message_Instance::croppedformat() const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.croppedformat)
  return *croppedformat_;
}
inline void Message_Instance::set_croppedformat(const ::std::string& value) {
  set_has_croppedformat();
  if (croppedformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    croppedformat_ = new ::std::string;
  }
  croppedformat_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Instance.croppedformat)
}
inline void Message_Instance::set_croppedformat(const char* value) {
  set_has_croppedformat();
  if (croppedformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    croppedformat_ = new ::std::string;
  }
  croppedformat_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Instance.croppedformat)
}
inline void Message_Instance::set_croppedformat(const char* value, size_t size) {
  set_has_croppedformat();
  if (croppedformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    croppedformat_ = new ::std::string;
  }
  croppedformat_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Instance.croppedformat)
}
inline ::std::string* Message_Instance::mutable_croppedformat() {
  set_has_croppedformat();
  if (croppedformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    croppedformat_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.croppedformat)
  return croppedformat_;
}
inline ::std::string* Message_Instance::release_croppedformat() {
  clear_has_croppedformat();
  if (croppedformat_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = croppedformat_;
    croppedformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Instance::set_allocated_croppedformat(::std::string* croppedformat) {
  if (croppedformat_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete croppedformat_;
  }
  if (croppedformat) {
    set_has_croppedformat();
    croppedformat_ = croppedformat;
  } else {
    clear_has_croppedformat();
    croppedformat_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Instance.croppedformat)
}

// repeated .motion.Message.Image image = 6;
inline int Message_Instance::image_size() const {
  return image_.size();
}
inline void Message_Instance::clear_image() {
  image_.Clear();
}
inline const ::motion::Message_Image& Message_Instance::image(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.image)
  return image_.Get(index);
}
inline ::motion::Message_Image* Message_Instance::mutable_image(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.image)
  return image_.Mutable(index);
}
inline ::motion::Message_Image* Message_Instance::add_image() {
  // @@protoc_insertion_point(field_add:motion.Message.Instance.image)
  return image_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >&
Message_Instance::image() const {
  // @@protoc_insertion_point(field_list:motion.Message.Instance.image)
  return image_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Image >*
Message_Instance::mutable_image() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.Instance.image)
  return &image_;
}

// repeated .motion.Message.Crop crop = 7;
inline int Message_Instance::crop_size() const {
  return crop_.size();
}
inline void Message_Instance::clear_crop() {
  crop_.Clear();
}
inline const ::motion::Message_Crop& Message_Instance::crop(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.Instance.crop)
  return crop_.Get(index);
}
inline ::motion::Message_Crop* Message_Instance::mutable_crop(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.Instance.crop)
  return crop_.Mutable(index);
}
inline ::motion::Message_Crop* Message_Instance::add_crop() {
  // @@protoc_insertion_point(field_add:motion.Message.Instance.crop)
  return crop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >&
Message_Instance::crop() const {
  // @@protoc_insertion_point(field_list:motion.Message.Instance.crop)
  return crop_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_Crop >*
Message_Instance::mutable_crop() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.Instance.crop)
  return &crop_;
}

// -------------------------------------------------------------------

// Message_Image

// optional string path = 1;
inline bool Message_Image::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Image::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Image::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Image::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Message_Image::path() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.path)
  return *path_;
}
inline void Message_Image::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Image.path)
}
inline void Message_Image::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Image.path)
}
inline void Message_Image::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Image.path)
}
inline ::std::string* Message_Image::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Image.path)
  return path_;
}
inline ::std::string* Message_Image::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Image::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Image.path)
}

// optional string name = 2;
inline bool Message_Image::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Image::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Image::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Image::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Message_Image::name() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.name)
  return *name_;
}
inline void Message_Image::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Image.name)
}
inline void Message_Image::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Image.name)
}
inline void Message_Image::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Image.name)
}
inline ::std::string* Message_Image::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Image.name)
  return name_;
}
inline ::std::string* Message_Image::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Image::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Image.name)
}

// optional int32 imagechanges = 3;
inline bool Message_Image::has_imagechanges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Image::set_has_imagechanges() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Image::clear_has_imagechanges() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Image::clear_imagechanges() {
  imagechanges_ = 0;
  clear_has_imagechanges();
}
inline ::google::protobuf::int32 Message_Image::imagechanges() const {
  // @@protoc_insertion_point(field_get:motion.Message.Image.imagechanges)
  return imagechanges_;
}
inline void Message_Image::set_imagechanges(::google::protobuf::int32 value) {
  set_has_imagechanges();
  imagechanges_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.Image.imagechanges)
}

// -------------------------------------------------------------------

// Message_Crop

// optional string path = 1;
inline bool Message_Crop::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_Crop::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_Crop::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_Crop::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Message_Crop::path() const {
  // @@protoc_insertion_point(field_get:motion.Message.Crop.path)
  return *path_;
}
inline void Message_Crop::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Crop.path)
}
inline void Message_Crop::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Crop.path)
}
inline void Message_Crop::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Crop.path)
}
inline ::std::string* Message_Crop::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Crop.path)
  return path_;
}
inline ::std::string* Message_Crop::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Crop::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Crop.path)
}

// optional string name = 2;
inline bool Message_Crop::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_Crop::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_Crop::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_Crop::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Message_Crop::name() const {
  // @@protoc_insertion_point(field_get:motion.Message.Crop.name)
  return *name_;
}
inline void Message_Crop::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Crop.name)
}
inline void Message_Crop::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Crop.name)
}
inline void Message_Crop::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Crop.name)
}
inline ::std::string* Message_Crop::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Crop.name)
  return name_;
}
inline ::std::string* Message_Crop::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Crop::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Crop.name)
}

// optional string imagefather = 3;
inline bool Message_Crop::has_imagefather() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message_Crop::set_has_imagefather() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message_Crop::clear_has_imagefather() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message_Crop::clear_imagefather() {
  if (imagefather_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefather_->clear();
  }
  clear_has_imagefather();
}
inline const ::std::string& Message_Crop::imagefather() const {
  // @@protoc_insertion_point(field_get:motion.Message.Crop.imagefather)
  return *imagefather_;
}
inline void Message_Crop::set_imagefather(const ::std::string& value) {
  set_has_imagefather();
  if (imagefather_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefather_ = new ::std::string;
  }
  imagefather_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.Crop.imagefather)
}
inline void Message_Crop::set_imagefather(const char* value) {
  set_has_imagefather();
  if (imagefather_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefather_ = new ::std::string;
  }
  imagefather_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.Crop.imagefather)
}
inline void Message_Crop::set_imagefather(const char* value, size_t size) {
  set_has_imagefather();
  if (imagefather_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefather_ = new ::std::string;
  }
  imagefather_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.Crop.imagefather)
}
inline ::std::string* Message_Crop::mutable_imagefather() {
  set_has_imagefather();
  if (imagefather_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefather_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.Crop.imagefather)
  return imagefather_;
}
inline ::std::string* Message_Crop::release_imagefather() {
  clear_has_imagefather();
  if (imagefather_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imagefather_;
    imagefather_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message_Crop::set_allocated_imagefather(::std::string* imagefather) {
  if (imagefather_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imagefather_;
  }
  if (imagefather) {
    set_has_imagefather();
    imagefather_ = imagefather;
  } else {
    clear_has_imagefather();
    imagefather_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.Crop.imagefather)
}

// -------------------------------------------------------------------

// Message

// required .motion.Message.ActionType type = 1 [default = ENGAGE];
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1000;
  clear_has_type();
}
inline ::motion::Message_ActionType Message::type() const {
  // @@protoc_insertion_point(field_get:motion.Message.type)
  return static_cast< ::motion::Message_ActionType >(type_);
}
inline void Message::set_type(::motion::Message_ActionType value) {
  assert(::motion::Message_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.type)
}

// optional string time = 2;
inline bool Message::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Message::time() const {
  // @@protoc_insertion_point(field_get:motion.Message.time)
  return *time_;
}
inline void Message::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.time)
}
inline void Message::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.time)
}
inline void Message::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.time)
}
inline ::std::string* Message::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.time)
  return time_;
}
inline ::std::string* Message::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.time)
}

// optional bytes data = 3;
inline bool Message::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Message::data() const {
  // @@protoc_insertion_point(field_get:motion.Message.data)
  return *data_;
}
inline void Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.data)
}
inline void Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.data)
}
inline void Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.data)
}
inline ::std::string* Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.data)
  return data_;
}
inline ::std::string* Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.data)
}

// optional int32 data_amount = 4;
inline bool Message::has_data_amount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_data_amount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_data_amount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_data_amount() {
  data_amount_ = 0;
  clear_has_data_amount();
}
inline ::google::protobuf::int32 Message::data_amount() const {
  // @@protoc_insertion_point(field_get:motion.Message.data_amount)
  return data_amount_;
}
inline void Message::set_data_amount(::google::protobuf::int32 value) {
  set_has_data_amount();
  data_amount_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.data_amount)
}

// optional int32 data_total = 5;
inline bool Message::has_data_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_data_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_data_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_data_total() {
  data_total_ = 0;
  clear_has_data_total();
}
inline ::google::protobuf::int32 Message::data_total() const {
  // @@protoc_insertion_point(field_get:motion.Message.data_total)
  return data_total_;
}
inline void Message::set_data_total(::google::protobuf::int32 value) {
  set_has_data_total();
  data_total_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.data_total)
}

// optional string serverip = 6;
inline bool Message::has_serverip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_serverip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& Message::serverip() const {
  // @@protoc_insertion_point(field_get:motion.Message.serverip)
  return *serverip_;
}
inline void Message::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.serverip)
}
inline ::std::string* Message::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.serverip)
  return serverip_;
}
inline ::std::string* Message::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.serverip)
}

// optional string clientip = 7;
inline bool Message::has_clientip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_clientip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_clientip() {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_->clear();
  }
  clear_has_clientip();
}
inline const ::std::string& Message::clientip() const {
  // @@protoc_insertion_point(field_get:motion.Message.clientip)
  return *clientip_;
}
inline void Message::set_clientip(const ::std::string& value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.clientip)
}
inline ::std::string* Message::mutable_clientip() {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.clientip)
  return clientip_;
}
inline ::std::string* Message::release_clientip() {
  clear_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientip_;
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_clientip(::std::string* clientip) {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientip_;
  }
  if (clientip) {
    set_has_clientip();
    clientip_ = clientip;
  } else {
    clear_has_clientip();
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.clientip)
}

// optional bool recognizing = 8;
inline bool Message::has_recognizing() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_recognizing() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_recognizing() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_recognizing() {
  recognizing_ = false;
  clear_has_recognizing();
}
inline bool Message::recognizing() const {
  // @@protoc_insertion_point(field_get:motion.Message.recognizing)
  return recognizing_;
}
inline void Message::set_recognizing(bool value) {
  set_has_recognizing();
  recognizing_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.recognizing)
}

// repeated .motion.Message.MotionMonth motionmonth = 9;
inline int Message::motionmonth_size() const {
  return motionmonth_.size();
}
inline void Message::clear_motionmonth() {
  motionmonth_.Clear();
}
inline const ::motion::Message_MotionMonth& Message::motionmonth(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.motionmonth)
  return motionmonth_.Get(index);
}
inline ::motion::Message_MotionMonth* Message::mutable_motionmonth(int index) {
  // @@protoc_insertion_point(field_mutable:motion.Message.motionmonth)
  return motionmonth_.Mutable(index);
}
inline ::motion::Message_MotionMonth* Message::add_motionmonth() {
  // @@protoc_insertion_point(field_add:motion.Message.motionmonth)
  return motionmonth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >&
Message::motionmonth() const {
  // @@protoc_insertion_point(field_list:motion.Message.motionmonth)
  return motionmonth_;
}
inline ::google::protobuf::RepeatedPtrField< ::motion::Message_MotionMonth >*
Message::mutable_motionmonth() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.motionmonth)
  return &motionmonth_;
}

// optional bool storeimage = 10;
inline bool Message::has_storeimage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_storeimage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_storeimage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_storeimage() {
  storeimage_ = false;
  clear_has_storeimage();
}
inline bool Message::storeimage() const {
  // @@protoc_insertion_point(field_get:motion.Message.storeimage)
  return storeimage_;
}
inline void Message::set_storeimage(bool value) {
  set_has_storeimage();
  storeimage_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.storeimage)
}

// optional bool storecrop = 11;
inline bool Message::has_storecrop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Message::set_has_storecrop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Message::clear_has_storecrop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Message::clear_storecrop() {
  storecrop_ = false;
  clear_has_storecrop();
}
inline bool Message::storecrop() const {
  // @@protoc_insertion_point(field_get:motion.Message.storecrop)
  return storecrop_;
}
inline void Message::set_storecrop(bool value) {
  set_has_storecrop();
  storecrop_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.storecrop)
}

// optional string codename = 12;
inline bool Message::has_codename() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Message::set_has_codename() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Message::clear_has_codename() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Message::clear_codename() {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_->clear();
  }
  clear_has_codename();
}
inline const ::std::string& Message::codename() const {
  // @@protoc_insertion_point(field_get:motion.Message.codename)
  return *codename_;
}
inline void Message::set_codename(const ::std::string& value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.codename)
}
inline void Message::set_codename(const char* value) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.codename)
}
inline void Message::set_codename(const char* value, size_t size) {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  codename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.codename)
}
inline ::std::string* Message::mutable_codename() {
  set_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    codename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.codename)
  return codename_;
}
inline ::std::string* Message::release_codename() {
  clear_has_codename();
  if (codename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = codename_;
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_codename(::std::string* codename) {
  if (codename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete codename_;
  }
  if (codename) {
    set_has_codename();
    codename_ = codename;
  } else {
    clear_has_codename();
    codename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.codename)
}

// optional bytes regioncoords = 13;
inline bool Message::has_regioncoords() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Message::set_has_regioncoords() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Message::clear_has_regioncoords() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Message::clear_regioncoords() {
  if (regioncoords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    regioncoords_->clear();
  }
  clear_has_regioncoords();
}
inline const ::std::string& Message::regioncoords() const {
  // @@protoc_insertion_point(field_get:motion.Message.regioncoords)
  return *regioncoords_;
}
inline void Message::set_regioncoords(const ::std::string& value) {
  set_has_regioncoords();
  if (regioncoords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    regioncoords_ = new ::std::string;
  }
  regioncoords_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.regioncoords)
}
inline void Message::set_regioncoords(const char* value) {
  set_has_regioncoords();
  if (regioncoords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    regioncoords_ = new ::std::string;
  }
  regioncoords_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.regioncoords)
}
inline void Message::set_regioncoords(const void* value, size_t size) {
  set_has_regioncoords();
  if (regioncoords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    regioncoords_ = new ::std::string;
  }
  regioncoords_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.regioncoords)
}
inline ::std::string* Message::mutable_regioncoords() {
  set_has_regioncoords();
  if (regioncoords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    regioncoords_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.regioncoords)
  return regioncoords_;
}
inline ::std::string* Message::release_regioncoords() {
  clear_has_regioncoords();
  if (regioncoords_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = regioncoords_;
    regioncoords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_regioncoords(::std::string* regioncoords) {
  if (regioncoords_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete regioncoords_;
  }
  if (regioncoords) {
    set_has_regioncoords();
    regioncoords_ = regioncoords;
  } else {
    clear_has_regioncoords();
    regioncoords_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.regioncoords)
}

// optional double delay = 14;
inline bool Message::has_delay() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Message::set_has_delay() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Message::clear_has_delay() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Message::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline double Message::delay() const {
  // @@protoc_insertion_point(field_get:motion.Message.delay)
  return delay_;
}
inline void Message::set_delay(double value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.delay)
}

// optional string starttime = 15;
inline bool Message::has_starttime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Message::set_has_starttime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Message::clear_has_starttime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Message::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& Message::starttime() const {
  // @@protoc_insertion_point(field_get:motion.Message.starttime)
  return *starttime_;
}
inline void Message::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.starttime)
}
inline void Message::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.starttime)
}
inline void Message::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.starttime)
}
inline ::std::string* Message::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    starttime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.starttime)
  return starttime_;
}
inline ::std::string* Message::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.starttime)
}

// optional string startrecognitiontime = 16;
inline bool Message::has_startrecognitiontime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Message::set_has_startrecognitiontime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Message::clear_has_startrecognitiontime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Message::clear_startrecognitiontime() {
  if (startrecognitiontime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrecognitiontime_->clear();
  }
  clear_has_startrecognitiontime();
}
inline const ::std::string& Message::startrecognitiontime() const {
  // @@protoc_insertion_point(field_get:motion.Message.startrecognitiontime)
  return *startrecognitiontime_;
}
inline void Message::set_startrecognitiontime(const ::std::string& value) {
  set_has_startrecognitiontime();
  if (startrecognitiontime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrecognitiontime_ = new ::std::string;
  }
  startrecognitiontime_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.startrecognitiontime)
}
inline void Message::set_startrecognitiontime(const char* value) {
  set_has_startrecognitiontime();
  if (startrecognitiontime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrecognitiontime_ = new ::std::string;
  }
  startrecognitiontime_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.startrecognitiontime)
}
inline void Message::set_startrecognitiontime(const char* value, size_t size) {
  set_has_startrecognitiontime();
  if (startrecognitiontime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrecognitiontime_ = new ::std::string;
  }
  startrecognitiontime_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.startrecognitiontime)
}
inline ::std::string* Message::mutable_startrecognitiontime() {
  set_has_startrecognitiontime();
  if (startrecognitiontime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    startrecognitiontime_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.startrecognitiontime)
  return startrecognitiontime_;
}
inline ::std::string* Message::release_startrecognitiontime() {
  clear_has_startrecognitiontime();
  if (startrecognitiontime_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = startrecognitiontime_;
    startrecognitiontime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_startrecognitiontime(::std::string* startrecognitiontime) {
  if (startrecognitiontime_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete startrecognitiontime_;
  }
  if (startrecognitiontime) {
    set_has_startrecognitiontime();
    startrecognitiontime_ = startrecognitiontime;
  } else {
    clear_has_startrecognitiontime();
    startrecognitiontime_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.startrecognitiontime)
}

// optional bool region = 17;
inline bool Message::has_region() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Message::set_has_region() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Message::clear_has_region() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Message::clear_region() {
  region_ = false;
  clear_has_region();
}
inline bool Message::region() const {
  // @@protoc_insertion_point(field_get:motion.Message.region)
  return region_;
}
inline void Message::set_region(bool value) {
  set_has_region();
  region_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.region)
}

// optional int32 numberofchanges = 18;
inline bool Message::has_numberofchanges() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Message::set_has_numberofchanges() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Message::clear_has_numberofchanges() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Message::clear_numberofchanges() {
  numberofchanges_ = 0;
  clear_has_numberofchanges();
}
inline ::google::protobuf::int32 Message::numberofchanges() const {
  // @@protoc_insertion_point(field_get:motion.Message.numberofchanges)
  return numberofchanges_;
}
inline void Message::set_numberofchanges(::google::protobuf::int32 value) {
  set_has_numberofchanges();
  numberofchanges_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.numberofchanges)
}

// optional int32 amount = 19;
inline bool Message::has_amount() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Message::set_has_amount() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Message::clear_has_amount() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Message::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 Message::amount() const {
  // @@protoc_insertion_point(field_get:motion.Message.amount)
  return amount_;
}
inline void Message::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.amount)
}

// repeated int32 matfile = 20;
inline int Message::matfile_size() const {
  return matfile_.size();
}
inline void Message::clear_matfile() {
  matfile_.Clear();
}
inline ::google::protobuf::int32 Message::matfile(int index) const {
  // @@protoc_insertion_point(field_get:motion.Message.matfile)
  return matfile_.Get(index);
}
inline void Message::set_matfile(int index, ::google::protobuf::int32 value) {
  matfile_.Set(index, value);
  // @@protoc_insertion_point(field_set:motion.Message.matfile)
}
inline void Message::add_matfile(::google::protobuf::int32 value) {
  matfile_.Add(value);
  // @@protoc_insertion_point(field_add:motion.Message.matfile)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Message::matfile() const {
  // @@protoc_insertion_point(field_list:motion.Message.matfile)
  return matfile_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Message::mutable_matfile() {
  // @@protoc_insertion_point(field_mutable_list:motion.Message.matfile)
  return &matfile_;
}

// optional int32 activemat = 21;
inline bool Message::has_activemat() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Message::set_has_activemat() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Message::clear_has_activemat() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Message::clear_activemat() {
  activemat_ = 0;
  clear_has_activemat();
}
inline ::google::protobuf::int32 Message::activemat() const {
  // @@protoc_insertion_point(field_get:motion.Message.activemat)
  return activemat_;
}
inline void Message::set_activemat(::google::protobuf::int32 value) {
  set_has_activemat();
  activemat_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.activemat)
}

// optional string cameras = 22;
inline bool Message::has_cameras() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Message::set_has_cameras() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Message::clear_has_cameras() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Message::clear_cameras() {
  if (cameras_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameras_->clear();
  }
  clear_has_cameras();
}
inline const ::std::string& Message::cameras() const {
  // @@protoc_insertion_point(field_get:motion.Message.cameras)
  return *cameras_;
}
inline void Message::set_cameras(const ::std::string& value) {
  set_has_cameras();
  if (cameras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameras_ = new ::std::string;
  }
  cameras_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.cameras)
}
inline void Message::set_cameras(const char* value) {
  set_has_cameras();
  if (cameras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameras_ = new ::std::string;
  }
  cameras_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.cameras)
}
inline void Message::set_cameras(const char* value, size_t size) {
  set_has_cameras();
  if (cameras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameras_ = new ::std::string;
  }
  cameras_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.cameras)
}
inline ::std::string* Message::mutable_cameras() {
  set_has_cameras();
  if (cameras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cameras_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.cameras)
  return cameras_;
}
inline ::std::string* Message::release_cameras() {
  clear_has_cameras();
  if (cameras_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cameras_;
    cameras_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_cameras(::std::string* cameras) {
  if (cameras_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cameras_;
  }
  if (cameras) {
    set_has_cameras();
    cameras_ = cameras;
  } else {
    clear_has_cameras();
    cameras_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.cameras)
}

// optional int32 activecamera = 23;
inline bool Message::has_activecamera() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Message::set_has_activecamera() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Message::clear_has_activecamera() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Message::clear_activecamera() {
  activecamera_ = 0;
  clear_has_activecamera();
}
inline ::google::protobuf::int32 Message::activecamera() const {
  // @@protoc_insertion_point(field_get:motion.Message.activecamera)
  return activecamera_;
}
inline void Message::set_activecamera(::google::protobuf::int32 value) {
  set_has_activecamera();
  activecamera_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.activecamera)
}

// optional string xmlfilename = 24;
inline bool Message::has_xmlfilename() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Message::set_has_xmlfilename() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Message::clear_has_xmlfilename() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Message::clear_xmlfilename() {
  if (xmlfilename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilename_->clear();
  }
  clear_has_xmlfilename();
}
inline const ::std::string& Message::xmlfilename() const {
  // @@protoc_insertion_point(field_get:motion.Message.xmlfilename)
  return *xmlfilename_;
}
inline void Message::set_xmlfilename(const ::std::string& value) {
  set_has_xmlfilename();
  if (xmlfilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilename_ = new ::std::string;
  }
  xmlfilename_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.xmlfilename)
}
inline void Message::set_xmlfilename(const char* value) {
  set_has_xmlfilename();
  if (xmlfilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilename_ = new ::std::string;
  }
  xmlfilename_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.xmlfilename)
}
inline void Message::set_xmlfilename(const char* value, size_t size) {
  set_has_xmlfilename();
  if (xmlfilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilename_ = new ::std::string;
  }
  xmlfilename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.xmlfilename)
}
inline ::std::string* Message::mutable_xmlfilename() {
  set_has_xmlfilename();
  if (xmlfilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.xmlfilename)
  return xmlfilename_;
}
inline ::std::string* Message::release_xmlfilename() {
  clear_has_xmlfilename();
  if (xmlfilename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xmlfilename_;
    xmlfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_xmlfilename(::std::string* xmlfilename) {
  if (xmlfilename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xmlfilename_;
  }
  if (xmlfilename) {
    set_has_xmlfilename();
    xmlfilename_ = xmlfilename;
  } else {
    clear_has_xmlfilename();
    xmlfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.xmlfilename)
}

// optional string xmlfilepath = 25;
inline bool Message::has_xmlfilepath() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Message::set_has_xmlfilepath() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Message::clear_has_xmlfilepath() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Message::clear_xmlfilepath() {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_->clear();
  }
  clear_has_xmlfilepath();
}
inline const ::std::string& Message::xmlfilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.xmlfilepath)
  return *xmlfilepath_;
}
inline void Message::set_xmlfilepath(const ::std::string& value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.xmlfilepath)
}
inline void Message::set_xmlfilepath(const char* value) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.xmlfilepath)
}
inline void Message::set_xmlfilepath(const char* value, size_t size) {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  xmlfilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.xmlfilepath)
}
inline ::std::string* Message::mutable_xmlfilepath() {
  set_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xmlfilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.xmlfilepath)
  return xmlfilepath_;
}
inline ::std::string* Message::release_xmlfilepath() {
  clear_has_xmlfilepath();
  if (xmlfilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xmlfilepath_;
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_xmlfilepath(::std::string* xmlfilepath) {
  if (xmlfilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xmlfilepath_;
  }
  if (xmlfilepath) {
    set_has_xmlfilepath();
    xmlfilepath_ = xmlfilepath;
  } else {
    clear_has_xmlfilepath();
    xmlfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.xmlfilepath)
}

// optional int32 instancecount = 26;
inline bool Message::has_instancecount() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Message::set_has_instancecount() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Message::clear_has_instancecount() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Message::clear_instancecount() {
  instancecount_ = 0;
  clear_has_instancecount();
}
inline ::google::protobuf::int32 Message::instancecount() const {
  // @@protoc_insertion_point(field_get:motion.Message.instancecount)
  return instancecount_;
}
inline void Message::set_instancecount(::google::protobuf::int32 value) {
  set_has_instancecount();
  instancecount_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.instancecount)
}

// optional string imagefilepath = 27;
inline bool Message::has_imagefilepath() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Message::set_has_imagefilepath() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Message::clear_has_imagefilepath() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Message::clear_imagefilepath() {
  if (imagefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_->clear();
  }
  clear_has_imagefilepath();
}
inline const ::std::string& Message::imagefilepath() const {
  // @@protoc_insertion_point(field_get:motion.Message.imagefilepath)
  return *imagefilepath_;
}
inline void Message::set_imagefilepath(const ::std::string& value) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.imagefilepath)
}
inline void Message::set_imagefilepath(const char* value) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.imagefilepath)
}
inline void Message::set_imagefilepath(const char* value, size_t size) {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  imagefilepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.imagefilepath)
}
inline ::std::string* Message::mutable_imagefilepath() {
  set_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imagefilepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.imagefilepath)
  return imagefilepath_;
}
inline ::std::string* Message::release_imagefilepath() {
  clear_has_imagefilepath();
  if (imagefilepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imagefilepath_;
    imagefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_imagefilepath(::std::string* imagefilepath) {
  if (imagefilepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imagefilepath_;
  }
  if (imagefilepath) {
    set_has_imagefilepath();
    imagefilepath_ = imagefilepath;
  } else {
    clear_has_imagefilepath();
    imagefilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.imagefilepath)
}

// optional string currmonth = 28;
inline bool Message::has_currmonth() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Message::set_has_currmonth() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Message::clear_has_currmonth() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Message::clear_currmonth() {
  if (currmonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_->clear();
  }
  clear_has_currmonth();
}
inline const ::std::string& Message::currmonth() const {
  // @@protoc_insertion_point(field_get:motion.Message.currmonth)
  return *currmonth_;
}
inline void Message::set_currmonth(const ::std::string& value) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.currmonth)
}
inline void Message::set_currmonth(const char* value) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.currmonth)
}
inline void Message::set_currmonth(const char* value, size_t size) {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  currmonth_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.currmonth)
}
inline ::std::string* Message::mutable_currmonth() {
  set_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currmonth_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.currmonth)
  return currmonth_;
}
inline ::std::string* Message::release_currmonth() {
  clear_has_currmonth();
  if (currmonth_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currmonth_;
    currmonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_currmonth(::std::string* currmonth) {
  if (currmonth_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currmonth_;
  }
  if (currmonth) {
    set_has_currmonth();
    currmonth_ = currmonth;
  } else {
    clear_has_currmonth();
    currmonth_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.currmonth)
}

// optional string currday = 29;
inline bool Message::has_currday() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Message::set_has_currday() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Message::clear_has_currday() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Message::clear_currday() {
  if (currday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_->clear();
  }
  clear_has_currday();
}
inline const ::std::string& Message::currday() const {
  // @@protoc_insertion_point(field_get:motion.Message.currday)
  return *currday_;
}
inline void Message::set_currday(const ::std::string& value) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.currday)
}
inline void Message::set_currday(const char* value) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.currday)
}
inline void Message::set_currday(const char* value, size_t size) {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  currday_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.currday)
}
inline ::std::string* Message::mutable_currday() {
  set_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    currday_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.currday)
  return currday_;
}
inline ::std::string* Message::release_currday() {
  clear_has_currday();
  if (currday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = currday_;
    currday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_currday(::std::string* currday) {
  if (currday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete currday_;
  }
  if (currday) {
    set_has_currday();
    currday_ = currday;
  } else {
    clear_has_currday();
    currday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.currday)
}

// optional int32 packagesize = 30;
inline bool Message::has_packagesize() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Message::set_has_packagesize() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Message::clear_has_packagesize() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Message::clear_packagesize() {
  packagesize_ = 0;
  clear_has_packagesize();
}
inline ::google::protobuf::int32 Message::packagesize() const {
  // @@protoc_insertion_point(field_get:motion.Message.packagesize)
  return packagesize_;
}
inline void Message::set_packagesize(::google::protobuf::int32 value) {
  set_has_packagesize();
  packagesize_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.packagesize)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace motion

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::motion::Message_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ActionType>() {
  return ::motion::Message_ActionType_descriptor();
}
template <> struct is_proto_enum< ::motion::Message_SocketType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_SocketType>() {
  return ::motion::Message_SocketType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motion_2eproto__INCLUDED
