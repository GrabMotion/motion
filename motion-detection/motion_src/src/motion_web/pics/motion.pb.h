// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motion.proto

#ifndef PROTOBUF_motion_2eproto__INCLUDED
#define PROTOBUF_motion_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace motion {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motion_2eproto();
void protobuf_AssignDesc_motion_2eproto();
void protobuf_ShutdownFile_motion_2eproto();

class Message;
class Recognition;
class Instance;
class Region;

enum Message_ActionType {
  Message_ActionType_CONNECT = 1000,
  Message_ActionType_STOP_STREAMING = 1002,
  Message_ActionType_PAUSE_STREAMING = 1003,
  Message_ActionType_START_RECOGNITION = 1004,
  Message_ActionType_STOP_RECOGNITION = 1005,
  Message_ActionType_DISSCONNECT = 1006,
  Message_ActionType_GET_TIME = 1007,
  Message_ActionType_SET_TIME = 1008,
  Message_ActionType_TIME_SET = 1009,
  Message_ActionType_AMOUNT_DETECTED = 1010,
  Message_ActionType_FILE_RECOGNIZED = 1011,
  Message_ActionType_GET_MAT = 1012,
  Message_ActionType_SET_MAT = 1013,
  Message_ActionType_TCP_ECHO_PORT = 5010,
  Message_ActionType_UDP_PORT = 5020,
  Message_ActionType_STREAMING_VIDEO_PORT = 5030,
  Message_ActionType_TCP_MSG_PORT = 5040
};
bool Message_ActionType_IsValid(int value);
const Message_ActionType Message_ActionType_ActionType_MIN = Message_ActionType_CONNECT;
const Message_ActionType Message_ActionType_ActionType_MAX = Message_ActionType_TCP_MSG_PORT;
const int Message_ActionType_ActionType_ARRAYSIZE = Message_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_ActionType_descriptor();
inline const ::std::string& Message_ActionType_Name(Message_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_ActionType_descriptor(), value);
}
inline bool Message_ActionType_Parse(
    const ::std::string& name, Message_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_ActionType>(
    Message_ActionType_descriptor(), name, value);
}
// ===================================================================

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_ActionType ActionType;
  static const ActionType CONNECT = Message_ActionType_CONNECT;
  static const ActionType STOP_STREAMING = Message_ActionType_STOP_STREAMING;
  static const ActionType PAUSE_STREAMING = Message_ActionType_PAUSE_STREAMING;
  static const ActionType START_RECOGNITION = Message_ActionType_START_RECOGNITION;
  static const ActionType STOP_RECOGNITION = Message_ActionType_STOP_RECOGNITION;
  static const ActionType DISSCONNECT = Message_ActionType_DISSCONNECT;
  static const ActionType GET_TIME = Message_ActionType_GET_TIME;
  static const ActionType SET_TIME = Message_ActionType_SET_TIME;
  static const ActionType TIME_SET = Message_ActionType_TIME_SET;
  static const ActionType AMOUNT_DETECTED = Message_ActionType_AMOUNT_DETECTED;
  static const ActionType FILE_RECOGNIZED = Message_ActionType_FILE_RECOGNIZED;
  static const ActionType GET_MAT = Message_ActionType_GET_MAT;
  static const ActionType SET_MAT = Message_ActionType_SET_MAT;
  static const ActionType TCP_ECHO_PORT = Message_ActionType_TCP_ECHO_PORT;
  static const ActionType UDP_PORT = Message_ActionType_UDP_PORT;
  static const ActionType STREAMING_VIDEO_PORT = Message_ActionType_STREAMING_VIDEO_PORT;
  static const ActionType TCP_MSG_PORT = Message_ActionType_TCP_MSG_PORT;
  static inline bool ActionType_IsValid(int value) {
    return Message_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Message_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Message_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Message_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Message_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Message_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Message_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .motion.Message.ActionType type = 1 [default = CONNECT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::motion::Message_ActionType type() const;
  inline void set_type(::motion::Message_ActionType value);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional int32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // optional int32 height = 4;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 4;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // optional int32 rows = 5;
  inline bool has_rows() const;
  inline void clear_rows();
  static const int kRowsFieldNumber = 5;
  inline ::google::protobuf::int32 rows() const;
  inline void set_rows(::google::protobuf::int32 value);

  // optional int32 cols = 6;
  inline bool has_cols() const;
  inline void clear_cols();
  static const int kColsFieldNumber = 6;
  inline ::google::protobuf::int32 cols() const;
  inline void set_cols(::google::protobuf::int32 value);

  // optional bytes data = 7;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 7;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional string serverip = 8;
  inline bool has_serverip() const;
  inline void clear_serverip();
  static const int kServeripFieldNumber = 8;
  inline const ::std::string& serverip() const;
  inline void set_serverip(const ::std::string& value);
  inline void set_serverip(const char* value);
  inline void set_serverip(const char* value, size_t size);
  inline ::std::string* mutable_serverip();
  inline ::std::string* release_serverip();
  inline void set_allocated_serverip(::std::string* serverip);

  // optional string clientip = 9;
  inline bool has_clientip() const;
  inline void clear_clientip();
  static const int kClientipFieldNumber = 9;
  inline const ::std::string& clientip() const;
  inline void set_clientip(const ::std::string& value);
  inline void set_clientip(const char* value);
  inline void set_clientip(const char* value, size_t size);
  inline ::std::string* mutable_clientip();
  inline ::std::string* release_clientip();
  inline void set_allocated_clientip(::std::string* clientip);

  // optional string payload = 10;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 10;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:motion.Message)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_rows();
  inline void clear_has_rows();
  inline void set_has_cols();
  inline void clear_has_cols();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_serverip();
  inline void clear_has_serverip();
  inline void set_has_clientip();
  inline void clear_has_clientip();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_;
  int type_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 rows_;
  ::std::string* data_;
  ::std::string* serverip_;
  ::std::string* clientip_;
  ::std::string* payload_;
  ::google::protobuf::int32 cols_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Recognition : public ::google::protobuf::Message {
 public:
  Recognition();
  virtual ~Recognition();

  Recognition(const Recognition& from);

  inline Recognition& operator=(const Recognition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Recognition& default_instance();

  void Swap(Recognition* other);

  // implements Message ----------------------------------------------

  Recognition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Recognition& from);
  void MergeFrom(const Recognition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 instance = 1;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 1;
  inline ::google::protobuf::int32 instance() const;
  inline void set_instance(::google::protobuf::int32 value);

  // optional bool setStoreImage = 2;
  inline bool has_setstoreimage() const;
  inline void clear_setstoreimage();
  static const int kSetStoreImageFieldNumber = 2;
  inline bool setstoreimage() const;
  inline void set_setstoreimage(bool value);

  // optional bool setSendAmount = 3;
  inline bool has_setsendamount() const;
  inline void clear_setsendamount();
  static const int kSetSendAmountFieldNumber = 3;
  inline bool setsendamount() const;
  inline void set_setsendamount(bool value);

  // optional bool setSendFilePath = 4;
  inline bool has_setsendfilepath() const;
  inline void clear_setsendfilepath();
  static const int kSetSendFilePathFieldNumber = 4;
  inline bool setsendfilepath() const;
  inline void set_setsendfilepath(bool value);

  // optional string amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string filePath = 6;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilePathFieldNumber = 6;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:motion.Recognition)
 private:
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_setstoreimage();
  inline void clear_has_setstoreimage();
  inline void set_has_setsendamount();
  inline void clear_has_setsendamount();
  inline void set_has_setsendfilepath();
  inline void clear_has_setsendfilepath();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_filepath();
  inline void clear_has_filepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 instance_;
  bool setstoreimage_;
  bool setsendamount_;
  bool setsendfilepath_;
  ::std::string* amount_;
  ::std::string* filepath_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Recognition* default_instance_;
};
// -------------------------------------------------------------------

class Instance : public ::google::protobuf::Message {
 public:
  Instance();
  virtual ~Instance();

  Instance(const Instance& from);

  inline Instance& operator=(const Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instance& default_instance();

  void Swap(Instance* other);

  // implements Message ----------------------------------------------

  Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instance& from);
  void MergeFrom(const Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idInstance = 1;
  inline bool has_idinstance() const;
  inline void clear_idinstance();
  static const int kIdInstanceFieldNumber = 1;
  inline ::google::protobuf::int32 idinstance() const;
  inline void set_idinstance(::google::protobuf::int32 value);

  // required string start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline const ::std::string& start() const;
  inline void set_start(const ::std::string& value);
  inline void set_start(const char* value);
  inline void set_start(const char* value, size_t size);
  inline ::std::string* mutable_start();
  inline ::std::string* release_start();
  inline void set_allocated_start(::std::string* start);

  // required string end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline const ::std::string& end() const;
  inline void set_end(const ::std::string& value);
  inline void set_end(const char* value);
  inline void set_end(const char* value, size_t size);
  inline ::std::string* mutable_end();
  inline ::std::string* release_end();
  inline void set_allocated_end(::std::string* end);

  // @@protoc_insertion_point(class_scope:motion.Instance)
 private:
  inline void set_has_idinstance();
  inline void clear_has_idinstance();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_;
  ::std::string* end_;
  ::google::protobuf::int32 idinstance_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Instance* default_instance_;
};
// -------------------------------------------------------------------

class Region : public ::google::protobuf::Message {
 public:
  Region();
  virtual ~Region();

  Region(const Region& from);

  inline Region& operator=(const Region& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Region& default_instance();

  void Swap(Region* other);

  // implements Message ----------------------------------------------

  Region* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Region& from);
  void MergeFrom(const Region& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required string xml_content = 2;
  inline bool has_xml_content() const;
  inline void clear_xml_content();
  static const int kXmlContentFieldNumber = 2;
  inline const ::std::string& xml_content() const;
  inline void set_xml_content(const ::std::string& value);
  inline void set_xml_content(const char* value);
  inline void set_xml_content(const char* value, size_t size);
  inline ::std::string* mutable_xml_content();
  inline ::std::string* release_xml_content();
  inline void set_allocated_xml_content(::std::string* xml_content);

  // @@protoc_insertion_point(class_scope:motion.Region)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_xml_content();
  inline void clear_has_xml_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  ::std::string* xml_content_;
  friend void  protobuf_AddDesc_motion_2eproto();
  friend void protobuf_AssignDesc_motion_2eproto();
  friend void protobuf_ShutdownFile_motion_2eproto();

  void InitAsDefaultInstance();
  static Region* default_instance_;
};
// ===================================================================


// ===================================================================

// Message

// required .motion.Message.ActionType type = 1 [default = CONNECT];
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_type() {
  type_ = 1000;
  clear_has_type();
}
inline ::motion::Message_ActionType Message::type() const {
  // @@protoc_insertion_point(field_get:motion.Message.type)
  return static_cast< ::motion::Message_ActionType >(type_);
}
inline void Message::set_type(::motion::Message_ActionType value) {
  assert(::motion::Message_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.type)
}

// optional string time = 2;
inline bool Message::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Message::time() const {
  // @@protoc_insertion_point(field_get:motion.Message.time)
  return *time_;
}
inline void Message::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.time)
}
inline void Message::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.time)
}
inline void Message::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.time)
}
inline ::std::string* Message::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.time)
  return time_;
}
inline ::std::string* Message::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.time)
}

// optional int32 width = 3;
inline bool Message::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Message::width() const {
  // @@protoc_insertion_point(field_get:motion.Message.width)
  return width_;
}
inline void Message::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.width)
}

// optional int32 height = 4;
inline bool Message::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Message::height() const {
  // @@protoc_insertion_point(field_get:motion.Message.height)
  return height_;
}
inline void Message::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.height)
}

// optional int32 rows = 5;
inline bool Message::has_rows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Message::set_has_rows() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Message::clear_has_rows() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Message::clear_rows() {
  rows_ = 0;
  clear_has_rows();
}
inline ::google::protobuf::int32 Message::rows() const {
  // @@protoc_insertion_point(field_get:motion.Message.rows)
  return rows_;
}
inline void Message::set_rows(::google::protobuf::int32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.rows)
}

// optional int32 cols = 6;
inline bool Message::has_cols() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Message::set_has_cols() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Message::clear_has_cols() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Message::clear_cols() {
  cols_ = 0;
  clear_has_cols();
}
inline ::google::protobuf::int32 Message::cols() const {
  // @@protoc_insertion_point(field_get:motion.Message.cols)
  return cols_;
}
inline void Message::set_cols(::google::protobuf::int32 value) {
  set_has_cols();
  cols_ = value;
  // @@protoc_insertion_point(field_set:motion.Message.cols)
}

// optional bytes data = 7;
inline bool Message::has_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Message::set_has_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Message::clear_has_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Message::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Message::data() const {
  // @@protoc_insertion_point(field_get:motion.Message.data)
  return *data_;
}
inline void Message::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.data)
}
inline void Message::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.data)
}
inline void Message::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.data)
}
inline ::std::string* Message::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.data)
  return data_;
}
inline ::std::string* Message::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.data)
}

// optional string serverip = 8;
inline bool Message::has_serverip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Message::set_has_serverip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Message::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Message::clear_serverip() {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_->clear();
  }
  clear_has_serverip();
}
inline const ::std::string& Message::serverip() const {
  // @@protoc_insertion_point(field_get:motion.Message.serverip)
  return *serverip_;
}
inline void Message::set_serverip(const ::std::string& value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.serverip)
}
inline void Message::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  serverip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.serverip)
}
inline ::std::string* Message::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serverip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.serverip)
  return serverip_;
}
inline ::std::string* Message::release_serverip() {
  clear_has_serverip();
  if (serverip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serverip_;
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_serverip(::std::string* serverip) {
  if (serverip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serverip_;
  }
  if (serverip) {
    set_has_serverip();
    serverip_ = serverip;
  } else {
    clear_has_serverip();
    serverip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.serverip)
}

// optional string clientip = 9;
inline bool Message::has_clientip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Message::set_has_clientip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Message::clear_has_clientip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Message::clear_clientip() {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_->clear();
  }
  clear_has_clientip();
}
inline const ::std::string& Message::clientip() const {
  // @@protoc_insertion_point(field_get:motion.Message.clientip)
  return *clientip_;
}
inline void Message::set_clientip(const ::std::string& value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.clientip)
}
inline void Message::set_clientip(const char* value, size_t size) {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  clientip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.clientip)
}
inline ::std::string* Message::mutable_clientip() {
  set_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    clientip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.clientip)
  return clientip_;
}
inline ::std::string* Message::release_clientip() {
  clear_has_clientip();
  if (clientip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = clientip_;
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_clientip(::std::string* clientip) {
  if (clientip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete clientip_;
  }
  if (clientip) {
    set_has_clientip();
    clientip_ = clientip;
  } else {
    clear_has_clientip();
    clientip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.clientip)
}

// optional string payload = 10;
inline bool Message::has_payload() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Message::set_has_payload() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Message::clear_has_payload() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Message::clear_payload() {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& Message::payload() const {
  // @@protoc_insertion_point(field_get:motion.Message.payload)
  return *payload_;
}
inline void Message::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Message.payload)
}
inline void Message::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Message.payload)
}
inline void Message::set_payload(const char* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Message.payload)
}
inline ::std::string* Message::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    payload_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Message.payload)
  return payload_;
}
inline ::std::string* Message::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Message::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Message.payload)
}

// -------------------------------------------------------------------

// Recognition

// required int32 instance = 1;
inline bool Recognition::has_instance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Recognition::set_has_instance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Recognition::clear_has_instance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Recognition::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 Recognition::instance() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.instance)
  return instance_;
}
inline void Recognition::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
  // @@protoc_insertion_point(field_set:motion.Recognition.instance)
}

// optional bool setStoreImage = 2;
inline bool Recognition::has_setstoreimage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Recognition::set_has_setstoreimage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Recognition::clear_has_setstoreimage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Recognition::clear_setstoreimage() {
  setstoreimage_ = false;
  clear_has_setstoreimage();
}
inline bool Recognition::setstoreimage() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.setStoreImage)
  return setstoreimage_;
}
inline void Recognition::set_setstoreimage(bool value) {
  set_has_setstoreimage();
  setstoreimage_ = value;
  // @@protoc_insertion_point(field_set:motion.Recognition.setStoreImage)
}

// optional bool setSendAmount = 3;
inline bool Recognition::has_setsendamount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Recognition::set_has_setsendamount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Recognition::clear_has_setsendamount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Recognition::clear_setsendamount() {
  setsendamount_ = false;
  clear_has_setsendamount();
}
inline bool Recognition::setsendamount() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.setSendAmount)
  return setsendamount_;
}
inline void Recognition::set_setsendamount(bool value) {
  set_has_setsendamount();
  setsendamount_ = value;
  // @@protoc_insertion_point(field_set:motion.Recognition.setSendAmount)
}

// optional bool setSendFilePath = 4;
inline bool Recognition::has_setsendfilepath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Recognition::set_has_setsendfilepath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Recognition::clear_has_setsendfilepath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Recognition::clear_setsendfilepath() {
  setsendfilepath_ = false;
  clear_has_setsendfilepath();
}
inline bool Recognition::setsendfilepath() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.setSendFilePath)
  return setsendfilepath_;
}
inline void Recognition::set_setsendfilepath(bool value) {
  set_has_setsendfilepath();
  setsendfilepath_ = value;
  // @@protoc_insertion_point(field_set:motion.Recognition.setSendFilePath)
}

// optional string amount = 5;
inline bool Recognition::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Recognition::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Recognition::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Recognition::clear_amount() {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& Recognition::amount() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.amount)
  return *amount_;
}
inline void Recognition::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Recognition.amount)
}
inline void Recognition::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Recognition.amount)
}
inline void Recognition::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Recognition.amount)
}
inline ::std::string* Recognition::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Recognition.amount)
  return amount_;
}
inline ::std::string* Recognition::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognition::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Recognition.amount)
}

// optional string filePath = 6;
inline bool Recognition::has_filepath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Recognition::set_has_filepath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Recognition::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Recognition::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& Recognition::filepath() const {
  // @@protoc_insertion_point(field_get:motion.Recognition.filePath)
  return *filepath_;
}
inline void Recognition::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Recognition.filePath)
}
inline void Recognition::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Recognition.filePath)
}
inline void Recognition::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Recognition.filePath)
}
inline ::std::string* Recognition::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Recognition.filePath)
  return filepath_;
}
inline ::std::string* Recognition::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Recognition::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Recognition.filePath)
}

// -------------------------------------------------------------------

// Instance

// required int32 idInstance = 1;
inline bool Instance::has_idinstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instance::set_has_idinstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instance::clear_has_idinstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instance::clear_idinstance() {
  idinstance_ = 0;
  clear_has_idinstance();
}
inline ::google::protobuf::int32 Instance::idinstance() const {
  // @@protoc_insertion_point(field_get:motion.Instance.idInstance)
  return idinstance_;
}
inline void Instance::set_idinstance(::google::protobuf::int32 value) {
  set_has_idinstance();
  idinstance_ = value;
  // @@protoc_insertion_point(field_set:motion.Instance.idInstance)
}

// required string start = 2;
inline bool Instance::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instance::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instance::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instance::clear_start() {
  if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_->clear();
  }
  clear_has_start();
}
inline const ::std::string& Instance::start() const {
  // @@protoc_insertion_point(field_get:motion.Instance.start)
  return *start_;
}
inline void Instance::set_start(const ::std::string& value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Instance.start)
}
inline void Instance::set_start(const char* value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Instance.start)
}
inline void Instance::set_start(const char* value, size_t size) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Instance.start)
}
inline ::std::string* Instance::mutable_start() {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Instance.start)
  return start_;
}
inline ::std::string* Instance::release_start() {
  clear_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_;
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instance::set_allocated_start(::std::string* start) {
  if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_;
  }
  if (start) {
    set_has_start();
    start_ = start;
  } else {
    clear_has_start();
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Instance.start)
}

// required string end = 3;
inline bool Instance::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Instance::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Instance::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Instance::clear_end() {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_->clear();
  }
  clear_has_end();
}
inline const ::std::string& Instance::end() const {
  // @@protoc_insertion_point(field_get:motion.Instance.end)
  return *end_;
}
inline void Instance::set_end(const ::std::string& value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Instance.end)
}
inline void Instance::set_end(const char* value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Instance.end)
}
inline void Instance::set_end(const char* value, size_t size) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Instance.end)
}
inline ::std::string* Instance::mutable_end() {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Instance.end)
  return end_;
}
inline ::std::string* Instance::release_end() {
  clear_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_;
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Instance::set_allocated_end(::std::string* end) {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_;
  }
  if (end) {
    set_has_end();
    end_ = end;
  } else {
    clear_has_end();
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Instance.end)
}

// -------------------------------------------------------------------

// Region

// required string fileName = 1;
inline bool Region::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Region::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Region::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Region::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& Region::filename() const {
  // @@protoc_insertion_point(field_get:motion.Region.fileName)
  return *filename_;
}
inline void Region::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Region.fileName)
}
inline void Region::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Region.fileName)
}
inline void Region::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Region.fileName)
}
inline ::std::string* Region::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Region.fileName)
  return filename_;
}
inline ::std::string* Region::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Region::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Region.fileName)
}

// required string xml_content = 2;
inline bool Region::has_xml_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Region::set_has_xml_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Region::clear_has_xml_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Region::clear_xml_content() {
  if (xml_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xml_content_->clear();
  }
  clear_has_xml_content();
}
inline const ::std::string& Region::xml_content() const {
  // @@protoc_insertion_point(field_get:motion.Region.xml_content)
  return *xml_content_;
}
inline void Region::set_xml_content(const ::std::string& value) {
  set_has_xml_content();
  if (xml_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xml_content_ = new ::std::string;
  }
  xml_content_->assign(value);
  // @@protoc_insertion_point(field_set:motion.Region.xml_content)
}
inline void Region::set_xml_content(const char* value) {
  set_has_xml_content();
  if (xml_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xml_content_ = new ::std::string;
  }
  xml_content_->assign(value);
  // @@protoc_insertion_point(field_set_char:motion.Region.xml_content)
}
inline void Region::set_xml_content(const char* value, size_t size) {
  set_has_xml_content();
  if (xml_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xml_content_ = new ::std::string;
  }
  xml_content_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:motion.Region.xml_content)
}
inline ::std::string* Region::mutable_xml_content() {
  set_has_xml_content();
  if (xml_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    xml_content_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:motion.Region.xml_content)
  return xml_content_;
}
inline ::std::string* Region::release_xml_content() {
  clear_has_xml_content();
  if (xml_content_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = xml_content_;
    xml_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Region::set_allocated_xml_content(::std::string* xml_content) {
  if (xml_content_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete xml_content_;
  }
  if (xml_content) {
    set_has_xml_content();
    xml_content_ = xml_content;
  } else {
    clear_has_xml_content();
    xml_content_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:motion.Region.xml_content)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace motion

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::motion::Message_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::motion::Message_ActionType>() {
  return ::motion::Message_ActionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motion_2eproto__INCLUDED
