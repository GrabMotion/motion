// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: motion_protocol.proto

#ifndef PROTOBUF_motion_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_motion_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace detection {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_motion_5fprotocol_2eproto();
void protobuf_AssignDesc_motion_5fprotocol_2eproto();
void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

class Motion;
class Motion_Action;
class Motion_Recognition;
class Motion_Instance;
class Message;

enum Motion_ActionType {
  Motion_ActionType_CONNECT = 1000,
  Motion_ActionType_STOP_STREAMING = 1002,
  Motion_ActionType_PAUSE_STREAMING = 1003,
  Motion_ActionType_START_RECOGNITION = 1004,
  Motion_ActionType_STOP_RECOGNITION = 1005,
  Motion_ActionType_DISSCONNECT = 1006,
  Motion_ActionType_GET_TIME = 1007,
  Motion_ActionType_SET_TIME = 1008,
  Motion_ActionType_TIME_SET = 1009,
  Motion_ActionType_AMOUNT_DETECTED = 1010,
  Motion_ActionType_FILE_RECOGNIZED = 1011,
  Motion_ActionType_TCP_ECHO_PORT = 5010,
  Motion_ActionType_UDP_PORT = 5020,
  Motion_ActionType_STREAMING_VIDEO_PORT = 5030,
  Motion_ActionType_TCP_MSG_PORT = 5040
};
bool Motion_ActionType_IsValid(int value);
const Motion_ActionType Motion_ActionType_ActionType_MIN = Motion_ActionType_CONNECT;
const Motion_ActionType Motion_ActionType_ActionType_MAX = Motion_ActionType_TCP_MSG_PORT;
const int Motion_ActionType_ActionType_ARRAYSIZE = Motion_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Motion_ActionType_descriptor();
inline const ::std::string& Motion_ActionType_Name(Motion_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Motion_ActionType_descriptor(), value);
}
inline bool Motion_ActionType_Parse(
    const ::std::string& name, Motion_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Motion_ActionType>(
    Motion_ActionType_descriptor(), name, value);
}
// ===================================================================

class Motion_Action : public ::google::protobuf::Message {
 public:
  Motion_Action();
  virtual ~Motion_Action();

  Motion_Action(const Motion_Action& from);

  inline Motion_Action& operator=(const Motion_Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motion_Action& default_instance();

  void Swap(Motion_Action* other);

  // implements Message ----------------------------------------------

  Motion_Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motion_Action& from);
  void MergeFrom(const Motion_Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idAction = 1;
  inline bool has_idaction() const;
  inline void clear_idaction();
  static const int kIdActionFieldNumber = 1;
  inline ::google::protobuf::int32 idaction() const;
  inline void set_idaction(::google::protobuf::int32 value);

  // optional .detection.Motion.ActionType type = 2 [default = CONNECT];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::detection::Motion_ActionType type() const;
  inline void set_type(::detection::Motion_ActionType value);

  // @@protoc_insertion_point(class_scope:detection.Motion.Action)
 private:
  inline void set_has_idaction();
  inline void clear_has_idaction();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 idaction_;
  int type_;
  friend void  protobuf_AddDesc_motion_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_motion_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Motion_Action* default_instance_;
};
// -------------------------------------------------------------------

class Motion_Recognition : public ::google::protobuf::Message {
 public:
  Motion_Recognition();
  virtual ~Motion_Recognition();

  Motion_Recognition(const Motion_Recognition& from);

  inline Motion_Recognition& operator=(const Motion_Recognition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motion_Recognition& default_instance();

  void Swap(Motion_Recognition* other);

  // implements Message ----------------------------------------------

  Motion_Recognition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motion_Recognition& from);
  void MergeFrom(const Motion_Recognition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 instance = 1;
  inline bool has_instance() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 1;
  inline ::google::protobuf::int32 instance() const;
  inline void set_instance(::google::protobuf::int32 value);

  // optional bool storeImage = 2;
  inline bool has_storeimage() const;
  inline void clear_storeimage();
  static const int kStoreImageFieldNumber = 2;
  inline bool storeimage() const;
  inline void set_storeimage(bool value);

  // optional bool sendAmount = 3;
  inline bool has_sendamount() const;
  inline void clear_sendamount();
  static const int kSendAmountFieldNumber = 3;
  inline bool sendamount() const;
  inline void set_sendamount(bool value);

  // optional bool sendFilePath = 4;
  inline bool has_sendfilepath() const;
  inline void clear_sendfilepath();
  static const int kSendFilePathFieldNumber = 4;
  inline bool sendfilepath() const;
  inline void set_sendfilepath(bool value);

  // optional string amount = 5;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 5;
  inline const ::std::string& amount() const;
  inline void set_amount(const ::std::string& value);
  inline void set_amount(const char* value);
  inline void set_amount(const char* value, size_t size);
  inline ::std::string* mutable_amount();
  inline ::std::string* release_amount();
  inline void set_allocated_amount(::std::string* amount);

  // optional string filePath = 6;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilePathFieldNumber = 6;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:detection.Motion.Recognition)
 private:
  inline void set_has_instance();
  inline void clear_has_instance();
  inline void set_has_storeimage();
  inline void clear_has_storeimage();
  inline void set_has_sendamount();
  inline void clear_has_sendamount();
  inline void set_has_sendfilepath();
  inline void clear_has_sendfilepath();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_filepath();
  inline void clear_has_filepath();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 instance_;
  bool storeimage_;
  bool sendamount_;
  bool sendfilepath_;
  ::std::string* amount_;
  ::std::string* filepath_;
  friend void  protobuf_AddDesc_motion_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_motion_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Motion_Recognition* default_instance_;
};
// -------------------------------------------------------------------

class Motion_Instance : public ::google::protobuf::Message {
 public:
  Motion_Instance();
  virtual ~Motion_Instance();

  Motion_Instance(const Motion_Instance& from);

  inline Motion_Instance& operator=(const Motion_Instance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motion_Instance& default_instance();

  void Swap(Motion_Instance* other);

  // implements Message ----------------------------------------------

  Motion_Instance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motion_Instance& from);
  void MergeFrom(const Motion_Instance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 idInstance = 1;
  inline bool has_idinstance() const;
  inline void clear_idinstance();
  static const int kIdInstanceFieldNumber = 1;
  inline ::google::protobuf::int32 idinstance() const;
  inline void set_idinstance(::google::protobuf::int32 value);

  // required string start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline const ::std::string& start() const;
  inline void set_start(const ::std::string& value);
  inline void set_start(const char* value);
  inline void set_start(const char* value, size_t size);
  inline ::std::string* mutable_start();
  inline ::std::string* release_start();
  inline void set_allocated_start(::std::string* start);

  // required string end = 3;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 3;
  inline const ::std::string& end() const;
  inline void set_end(const ::std::string& value);
  inline void set_end(const char* value);
  inline void set_end(const char* value, size_t size);
  inline ::std::string* mutable_end();
  inline ::std::string* release_end();
  inline void set_allocated_end(::std::string* end);

  // @@protoc_insertion_point(class_scope:detection.Motion.Instance)
 private:
  inline void set_has_idinstance();
  inline void clear_has_idinstance();
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_;
  ::std::string* end_;
  ::google::protobuf::int32 idinstance_;
  friend void  protobuf_AddDesc_motion_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_motion_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Motion_Instance* default_instance_;
};
// -------------------------------------------------------------------

class Motion : public ::google::protobuf::Message {
 public:
  Motion();
  virtual ~Motion();

  Motion(const Motion& from);

  inline Motion& operator=(const Motion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motion& default_instance();

  void Swap(Motion* other);

  // implements Message ----------------------------------------------

  Motion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motion& from);
  void MergeFrom(const Motion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Motion_Action Action;
  typedef Motion_Recognition Recognition;
  typedef Motion_Instance Instance;

  typedef Motion_ActionType ActionType;
  static const ActionType CONNECT = Motion_ActionType_CONNECT;
  static const ActionType STOP_STREAMING = Motion_ActionType_STOP_STREAMING;
  static const ActionType PAUSE_STREAMING = Motion_ActionType_PAUSE_STREAMING;
  static const ActionType START_RECOGNITION = Motion_ActionType_START_RECOGNITION;
  static const ActionType STOP_RECOGNITION = Motion_ActionType_STOP_RECOGNITION;
  static const ActionType DISSCONNECT = Motion_ActionType_DISSCONNECT;
  static const ActionType GET_TIME = Motion_ActionType_GET_TIME;
  static const ActionType SET_TIME = Motion_ActionType_SET_TIME;
  static const ActionType TIME_SET = Motion_ActionType_TIME_SET;
  static const ActionType AMOUNT_DETECTED = Motion_ActionType_AMOUNT_DETECTED;
  static const ActionType FILE_RECOGNIZED = Motion_ActionType_FILE_RECOGNIZED;
  static const ActionType TCP_ECHO_PORT = Motion_ActionType_TCP_ECHO_PORT;
  static const ActionType UDP_PORT = Motion_ActionType_UDP_PORT;
  static const ActionType STREAMING_VIDEO_PORT = Motion_ActionType_STREAMING_VIDEO_PORT;
  static const ActionType TCP_MSG_PORT = Motion_ActionType_TCP_MSG_PORT;
  static inline bool ActionType_IsValid(int value) {
    return Motion_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    Motion_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    Motion_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    Motion_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return Motion_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return Motion_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return Motion_ActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 idMotion = 1;
  inline bool has_idmotion() const;
  inline void clear_idmotion();
  static const int kIdMotionFieldNumber = 1;
  inline ::google::protobuf::int32 idmotion() const;
  inline void set_idmotion(::google::protobuf::int32 value);

  // optional string time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string code = 3;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 3;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // repeated .detection.Motion.Action action = 4;
  inline int action_size() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline const ::detection::Motion_Action& action(int index) const;
  inline ::detection::Motion_Action* mutable_action(int index);
  inline ::detection::Motion_Action* add_action();
  inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion_Action >&
      action() const;
  inline ::google::protobuf::RepeatedPtrField< ::detection::Motion_Action >*
      mutable_action();

  // repeated .detection.Motion.Instance instance = 5;
  inline int instance_size() const;
  inline void clear_instance();
  static const int kInstanceFieldNumber = 5;
  inline const ::detection::Motion_Instance& instance(int index) const;
  inline ::detection::Motion_Instance* mutable_instance(int index);
  inline ::detection::Motion_Instance* add_instance();
  inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion_Instance >&
      instance() const;
  inline ::google::protobuf::RepeatedPtrField< ::detection::Motion_Instance >*
      mutable_instance();

  // @@protoc_insertion_point(class_scope:detection.Motion)
 private:
  inline void set_has_idmotion();
  inline void clear_has_idmotion();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* time_;
  ::std::string* code_;
  ::google::protobuf::RepeatedPtrField< ::detection::Motion_Action > action_;
  ::google::protobuf::RepeatedPtrField< ::detection::Motion_Instance > instance_;
  ::google::protobuf::int32 idmotion_;
  friend void  protobuf_AddDesc_motion_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_motion_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Motion* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .detection.Motion motion = 1;
  inline int motion_size() const;
  inline void clear_motion();
  static const int kMotionFieldNumber = 1;
  inline const ::detection::Motion& motion(int index) const;
  inline ::detection::Motion* mutable_motion(int index);
  inline ::detection::Motion* add_motion();
  inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion >&
      motion() const;
  inline ::google::protobuf::RepeatedPtrField< ::detection::Motion >*
      mutable_motion();

  // @@protoc_insertion_point(class_scope:detection.Message)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::detection::Motion > motion_;
  friend void  protobuf_AddDesc_motion_5fprotocol_2eproto();
  friend void protobuf_AssignDesc_motion_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_motion_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Motion_Action

// required int32 idAction = 1;
inline bool Motion_Action::has_idaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motion_Action::set_has_idaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motion_Action::clear_has_idaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motion_Action::clear_idaction() {
  idaction_ = 0;
  clear_has_idaction();
}
inline ::google::protobuf::int32 Motion_Action::idaction() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Action.idAction)
  return idaction_;
}
inline void Motion_Action::set_idaction(::google::protobuf::int32 value) {
  set_has_idaction();
  idaction_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Action.idAction)
}

// optional .detection.Motion.ActionType type = 2 [default = CONNECT];
inline bool Motion_Action::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motion_Action::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motion_Action::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motion_Action::clear_type() {
  type_ = 1000;
  clear_has_type();
}
inline ::detection::Motion_ActionType Motion_Action::type() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Action.type)
  return static_cast< ::detection::Motion_ActionType >(type_);
}
inline void Motion_Action::set_type(::detection::Motion_ActionType value) {
  assert(::detection::Motion_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Action.type)
}

// -------------------------------------------------------------------

// Motion_Recognition

// required int32 instance = 1;
inline bool Motion_Recognition::has_instance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motion_Recognition::set_has_instance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motion_Recognition::clear_has_instance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motion_Recognition::clear_instance() {
  instance_ = 0;
  clear_has_instance();
}
inline ::google::protobuf::int32 Motion_Recognition::instance() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.instance)
  return instance_;
}
inline void Motion_Recognition::set_instance(::google::protobuf::int32 value) {
  set_has_instance();
  instance_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.instance)
}

// optional bool storeImage = 2;
inline bool Motion_Recognition::has_storeimage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motion_Recognition::set_has_storeimage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motion_Recognition::clear_has_storeimage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motion_Recognition::clear_storeimage() {
  storeimage_ = false;
  clear_has_storeimage();
}
inline bool Motion_Recognition::storeimage() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.storeImage)
  return storeimage_;
}
inline void Motion_Recognition::set_storeimage(bool value) {
  set_has_storeimage();
  storeimage_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.storeImage)
}

// optional bool sendAmount = 3;
inline bool Motion_Recognition::has_sendamount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motion_Recognition::set_has_sendamount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motion_Recognition::clear_has_sendamount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motion_Recognition::clear_sendamount() {
  sendamount_ = false;
  clear_has_sendamount();
}
inline bool Motion_Recognition::sendamount() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.sendAmount)
  return sendamount_;
}
inline void Motion_Recognition::set_sendamount(bool value) {
  set_has_sendamount();
  sendamount_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.sendAmount)
}

// optional bool sendFilePath = 4;
inline bool Motion_Recognition::has_sendfilepath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Motion_Recognition::set_has_sendfilepath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Motion_Recognition::clear_has_sendfilepath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Motion_Recognition::clear_sendfilepath() {
  sendfilepath_ = false;
  clear_has_sendfilepath();
}
inline bool Motion_Recognition::sendfilepath() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.sendFilePath)
  return sendfilepath_;
}
inline void Motion_Recognition::set_sendfilepath(bool value) {
  set_has_sendfilepath();
  sendfilepath_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.sendFilePath)
}

// optional string amount = 5;
inline bool Motion_Recognition::has_amount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Motion_Recognition::set_has_amount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Motion_Recognition::clear_has_amount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Motion_Recognition::clear_amount() {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_->clear();
  }
  clear_has_amount();
}
inline const ::std::string& Motion_Recognition::amount() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.amount)
  return *amount_;
}
inline void Motion_Recognition::set_amount(const ::std::string& value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.amount)
}
inline void Motion_Recognition::set_amount(const char* value) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.Recognition.amount)
}
inline void Motion_Recognition::set_amount(const char* value, size_t size) {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  amount_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.Recognition.amount)
}
inline ::std::string* Motion_Recognition::mutable_amount() {
  set_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    amount_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.Recognition.amount)
  return amount_;
}
inline ::std::string* Motion_Recognition::release_amount() {
  clear_has_amount();
  if (amount_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = amount_;
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion_Recognition::set_allocated_amount(::std::string* amount) {
  if (amount_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete amount_;
  }
  if (amount) {
    set_has_amount();
    amount_ = amount;
  } else {
    clear_has_amount();
    amount_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.Recognition.amount)
}

// optional string filePath = 6;
inline bool Motion_Recognition::has_filepath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Motion_Recognition::set_has_filepath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Motion_Recognition::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Motion_Recognition::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& Motion_Recognition::filepath() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Recognition.filePath)
  return *filepath_;
}
inline void Motion_Recognition::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.Recognition.filePath)
}
inline void Motion_Recognition::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.Recognition.filePath)
}
inline void Motion_Recognition::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.Recognition.filePath)
}
inline ::std::string* Motion_Recognition::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.Recognition.filePath)
  return filepath_;
}
inline ::std::string* Motion_Recognition::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion_Recognition::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.Recognition.filePath)
}

// -------------------------------------------------------------------

// Motion_Instance

// required int32 idInstance = 1;
inline bool Motion_Instance::has_idinstance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motion_Instance::set_has_idinstance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motion_Instance::clear_has_idinstance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motion_Instance::clear_idinstance() {
  idinstance_ = 0;
  clear_has_idinstance();
}
inline ::google::protobuf::int32 Motion_Instance::idinstance() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Instance.idInstance)
  return idinstance_;
}
inline void Motion_Instance::set_idinstance(::google::protobuf::int32 value) {
  set_has_idinstance();
  idinstance_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.Instance.idInstance)
}

// required string start = 2;
inline bool Motion_Instance::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motion_Instance::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motion_Instance::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motion_Instance::clear_start() {
  if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_->clear();
  }
  clear_has_start();
}
inline const ::std::string& Motion_Instance::start() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Instance.start)
  return *start_;
}
inline void Motion_Instance::set_start(const ::std::string& value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.Instance.start)
}
inline void Motion_Instance::set_start(const char* value) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.Instance.start)
}
inline void Motion_Instance::set_start(const char* value, size_t size) {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  start_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.Instance.start)
}
inline ::std::string* Motion_Instance::mutable_start() {
  set_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.Instance.start)
  return start_;
}
inline ::std::string* Motion_Instance::release_start() {
  clear_has_start();
  if (start_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_;
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion_Instance::set_allocated_start(::std::string* start) {
  if (start_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_;
  }
  if (start) {
    set_has_start();
    start_ = start;
  } else {
    clear_has_start();
    start_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.Instance.start)
}

// required string end = 3;
inline bool Motion_Instance::has_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motion_Instance::set_has_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motion_Instance::clear_has_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motion_Instance::clear_end() {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_->clear();
  }
  clear_has_end();
}
inline const ::std::string& Motion_Instance::end() const {
  // @@protoc_insertion_point(field_get:detection.Motion.Instance.end)
  return *end_;
}
inline void Motion_Instance::set_end(const ::std::string& value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.Instance.end)
}
inline void Motion_Instance::set_end(const char* value) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.Instance.end)
}
inline void Motion_Instance::set_end(const char* value, size_t size) {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  end_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.Instance.end)
}
inline ::std::string* Motion_Instance::mutable_end() {
  set_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    end_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.Instance.end)
  return end_;
}
inline ::std::string* Motion_Instance::release_end() {
  clear_has_end();
  if (end_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = end_;
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion_Instance::set_allocated_end(::std::string* end) {
  if (end_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete end_;
  }
  if (end) {
    set_has_end();
    end_ = end;
  } else {
    clear_has_end();
    end_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.Instance.end)
}

// -------------------------------------------------------------------

// Motion

// required int32 idMotion = 1;
inline bool Motion::has_idmotion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motion::set_has_idmotion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motion::clear_has_idmotion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motion::clear_idmotion() {
  idmotion_ = 0;
  clear_has_idmotion();
}
inline ::google::protobuf::int32 Motion::idmotion() const {
  // @@protoc_insertion_point(field_get:detection.Motion.idMotion)
  return idmotion_;
}
inline void Motion::set_idmotion(::google::protobuf::int32 value) {
  set_has_idmotion();
  idmotion_ = value;
  // @@protoc_insertion_point(field_set:detection.Motion.idMotion)
}

// optional string time = 2;
inline bool Motion::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motion::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motion::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motion::clear_time() {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& Motion::time() const {
  // @@protoc_insertion_point(field_get:detection.Motion.time)
  return *time_;
}
inline void Motion::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.time)
}
inline void Motion::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.time)
}
inline void Motion::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.time)
}
inline ::std::string* Motion::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    time_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.time)
  return time_;
}
inline ::std::string* Motion::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.time)
}

// optional string code = 3;
inline bool Motion::has_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motion::set_has_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motion::clear_has_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motion::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& Motion::code() const {
  // @@protoc_insertion_point(field_get:detection.Motion.code)
  return *code_;
}
inline void Motion::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:detection.Motion.code)
}
inline void Motion::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:detection.Motion.code)
}
inline void Motion::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:detection.Motion.code)
}
inline ::std::string* Motion::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:detection.Motion.code)
  return code_;
}
inline ::std::string* Motion::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Motion::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:detection.Motion.code)
}

// repeated .detection.Motion.Action action = 4;
inline int Motion::action_size() const {
  return action_.size();
}
inline void Motion::clear_action() {
  action_.Clear();
}
inline const ::detection::Motion_Action& Motion::action(int index) const {
  // @@protoc_insertion_point(field_get:detection.Motion.action)
  return action_.Get(index);
}
inline ::detection::Motion_Action* Motion::mutable_action(int index) {
  // @@protoc_insertion_point(field_mutable:detection.Motion.action)
  return action_.Mutable(index);
}
inline ::detection::Motion_Action* Motion::add_action() {
  // @@protoc_insertion_point(field_add:detection.Motion.action)
  return action_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion_Action >&
Motion::action() const {
  // @@protoc_insertion_point(field_list:detection.Motion.action)
  return action_;
}
inline ::google::protobuf::RepeatedPtrField< ::detection::Motion_Action >*
Motion::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:detection.Motion.action)
  return &action_;
}

// repeated .detection.Motion.Instance instance = 5;
inline int Motion::instance_size() const {
  return instance_.size();
}
inline void Motion::clear_instance() {
  instance_.Clear();
}
inline const ::detection::Motion_Instance& Motion::instance(int index) const {
  // @@protoc_insertion_point(field_get:detection.Motion.instance)
  return instance_.Get(index);
}
inline ::detection::Motion_Instance* Motion::mutable_instance(int index) {
  // @@protoc_insertion_point(field_mutable:detection.Motion.instance)
  return instance_.Mutable(index);
}
inline ::detection::Motion_Instance* Motion::add_instance() {
  // @@protoc_insertion_point(field_add:detection.Motion.instance)
  return instance_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion_Instance >&
Motion::instance() const {
  // @@protoc_insertion_point(field_list:detection.Motion.instance)
  return instance_;
}
inline ::google::protobuf::RepeatedPtrField< ::detection::Motion_Instance >*
Motion::mutable_instance() {
  // @@protoc_insertion_point(field_mutable_list:detection.Motion.instance)
  return &instance_;
}

// -------------------------------------------------------------------

// Message

// repeated .detection.Motion motion = 1;
inline int Message::motion_size() const {
  return motion_.size();
}
inline void Message::clear_motion() {
  motion_.Clear();
}
inline const ::detection::Motion& Message::motion(int index) const {
  // @@protoc_insertion_point(field_get:detection.Message.motion)
  return motion_.Get(index);
}
inline ::detection::Motion* Message::mutable_motion(int index) {
  // @@protoc_insertion_point(field_mutable:detection.Message.motion)
  return motion_.Mutable(index);
}
inline ::detection::Motion* Message::add_motion() {
  // @@protoc_insertion_point(field_add:detection.Message.motion)
  return motion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::detection::Motion >&
Message::motion() const {
  // @@protoc_insertion_point(field_list:detection.Message.motion)
  return motion_;
}
inline ::google::protobuf::RepeatedPtrField< ::detection::Motion >*
Message::mutable_motion() {
  // @@protoc_insertion_point(field_mutable_list:detection.Message.motion)
  return &motion_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace detection

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::detection::Motion_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::detection::Motion_ActionType>() {
  return ::detection::Motion_ActionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_motion_5fprotocol_2eproto__INCLUDED
